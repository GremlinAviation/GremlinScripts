--[[
DO NOT EDIT THIS FILE! Things WILL break that way.

Instead!

When calling `Evac:setup()`, you can pass in a configuration table instead
of `nil`. Make your changes in the table you pass - defaults are already in
place if you want to leave those out.

An example, providing all the defaults, is available near the end of this script.
]]
Evac = {
    -- Static Info

    -- Contains an identifier for this script
    Id = "Gremlin Evac",
    -- Contains tte current script version
    Version = "202403.01",

    -- Config

    -- How long a beacon should last, in minutes
    beaconBatteryLife = 0,
    -- The audio file to play for beacons
    beaconSound = "",
    -- The max carrying capacity of the aircraft in this misson
    -- Table should be a list of capacities keyed by the unit type name
    carryLimits = {},
    -- Where to start counting when generating new units' and groups' IDs
    idStart = 0,
    -- How long it takes to load one unit, in seconds
    loadUnloadPerIndividual = 0,
    -- The maximum number of each unit to generate when spawning units
    maxExtractable = {
        Refugees = 0,
        Infantry = 0,
        M249 = 0,
        RPG = 0,
        StingerIgla = 0,
        ["2B11"] = 0,
        JTAC = 0,
    },
    -- How frequently to spawn new units, per zone
    spawnRates = {},
    -- The default weight of new units; exact weights will vary by unit
    spawnWeight = 0,
    -- Internal State - DO NOT USE / MODIFY
    _state = {
        alreadyInitialized = false,
        beacons = {},
        extractableNow = {},
        extractionUnits = {},
        frequencies = {
            uhf = {
                free = {},
                used = {}
            },
            vhf = {
                free = {},
                used = {}
            },
            fm = {
                free = {},
                used = {}
            },
        },
        menuAdded = {},
        smoke = {},
        zones = {
            evac = {},
            relay = {},
            safe = {},
        },
    },
    -- The modes that a zone can be in
    modes = {
        EVAC = 1,
        SAFE = 2,
        RELAY = 3,
    },
    -- Lookup table for modes to names
    modeToText = {
        "evac",
        "safe",
        "relay",
    },
    -- Internal Methods - AVOID USING / DO NOT MODIFY
    _internal = {},
}

-- Methods

--- Zone methods
Evac.zones = {
    -- Evac Zone methods
    evac = {
        -- Mark a zone as part of the Evac ecosystem, and give it the evac mode
        register = function(_zone, _smoke, _side)
            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.EVAC)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            return Evac._internal.zones.activate(_zone, Evac.modes.EVAC)
        end,
        -- Manually override the remaining units in a zone
        setRemaining = function(_zone, _side, _country, _numberOrComposition)
            return Evac._internal.zones.setRemaining(_zone, _side, _country, _numberOrComposition)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            return Evac._internal.zones.count(_zone, Evac.modes.EVAC)
        end,
        -- Check whether a given unit is in an evac zone
        isIn = function(_unit)
            return Evac._internal.zones.isIn(_unit, Evac.modes.EVAC)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            return Evac._internal.zones.deactivate(_zone, Evac.modes.EVAC)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            return Evac._internal.zones.unregister(_zone, Evac.modes.EVAC)
        end,
    },
    -- Relay Zone methods
    relay = {
        -- Mark a zone as part of the Evac ecosystem, and give it the relay mode
        register = function(_zone, _smoke, _side)
            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.RELAY)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            return Evac._internal.zones.activate(_zone, Evac.modes.RELAY)
        end,
        -- Manually override the remaining units in a zone
        setRemaining = function(_zone, _side, _country, _numberOrComposition)
            return Evac._internal.zones.setRemaining(_zone, _side, _country, _numberOrComposition)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            return Evac._internal.zones.count(_zone, Evac.modes.RELAY)
        end,
        -- Check whether a given unit is in a relay zone
        isIn = function(_unit)
            return Evac._internal.zones.isIn(_unit, Evac.modes.RELAY)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            return Evac._internal.zones.deactivate(_zone, Evac.modes.RELAY)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            return Evac._internal.zones.unregister(_zone, Evac.modes.RELAY)
        end,
    },
    -- Safe Zone methods
    safe = {
        -- Mark a zone as part of the Evac ecosystem, and give it the safe mode
        register = function(_zone, _smoke, _side)
            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.SAFE)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            return Evac._internal.zones.activate(_zone, Evac.modes.SAFE)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            return Evac._internal.zones.count(_zone, Evac.modes.SAFE)
        end,
        -- Check whether a given unit is in a safe zone
        isIn = function(_unit)
            return Evac._internal.zones.isIn(_unit, Evac.modes.SAFE)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            return Evac._internal.zones.deactivate(_zone, Evac.modes.SAFE)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            return Evac._internal.zones.unregister(_zone, Evac.modes.SAFE)
        end,
    },
}

--- Unit methods
Evac.units = {
    -- Lists the currently active beacons broadcasting for the player's coalition
    findEvacuees = function(_unit)
        Evac._internal.beacons.list(_unit)
    end,
    -- Starts the evacuee loading process for a unit
    loadEvacuees = function(_unit)
        local _unitObj = Unit.getByName(_unit)
        if _unitObj ~= nil then
            local _free = Evac.carryLimits[_unitObj:getTypeName()] or 0
            _free = _free - Evac._internal.aircraft.countEvacuees(_unit)

            if _free <= 0 then
                Gremlin.displayMessageTo(_unit, "Already full! Unload, first!", timer.getTime() + 5)
                return
            end

            Evac._internal.aircraft.loadEvacuees(_unit, _free)
        else
            Gremlin.displayMessageTo(_unit, "Your aircraft isn't rated for evacuees in this mission!",
                timer.getTime() + 5)
        end
    end,
    -- Starts the evacuee unloading process for a unit
    unloadEvacuees = function(_unit)
        Evac._internal.aircraft.unloadEvacuees(_unit)
    end,
    -- Count the number of evacuees on board a given unit
    countEvacuees = function(_unit)
        local _count = Evac._internal.aircraft.countEvacuees(_unit)

        Gremlin.displayMessageTo(_unit, "You are currently carrying " .. _count .. " evacuees.", timer.getTime() + 5)
    end,
    -- Count the number of units in a given zone
    count = function(_zone)
        return #(mist.getUnitsInZones(mist.makeUnitTable({ "[all]" }, false), { _zone }, "c"))
    end,
}

--- Group methods
Evac.groups = {
    -- Spawns refugees when given a number for `_numberOrComposition`.
    -- For a mix of evac targets, pass a list of units to add instead.
    spawn = function(_side, _numberOrComposition, _country, _zone, _scatterRadius)
        local _groupData = Evac._internal.zones.generateEvacuees(_side, _numberOrComposition, _country)
        local _spawnZone = trigger.misc.getZone(_zone)

        if _spawnZone == nil then
            trigger.action.outText("GREMLIN EVAC ERROR: Can't find zone called " .. _zone, 10)
            return
        end

        if _scatterRadius < 5 then
            _scatterRadius = 5
        end

        local _pos2 = { x = _spawnZone.point.x, y = _spawnZone.point.z }
        local _alt = land.getHeight(_pos2)
        local _pos3 = { x = _pos2.x, y = _alt, z = _pos2.y }

        local _group = {
            visible = false,
            hidden = false,
            units = Evac._internal.utils.unitDataToList(_groupData.units, _pos3, _scatterRadius),
            name = _groupData.groupName,
            groupId = _groupData.groupId,
            category = Group.Category.GROUND,
            country = _groupData.country,
        }

        mist.dynAdd(_group)
        -- mist.teleportInZone(_group.name, _zone, true, _scatterRadius)

        for _, _unit in pairs(_groupData.units) do
            Evac._state.extractableNow[_zone][_unit.unitName] = _unit
        end

        return _group
    end,
    -- Returns a list of all groups in a zone
    list = function(_zone)
        local groupsFound = {}
        local _unitsInZone = mist.getUnitsInZones(mist.makeUnitTable({ "[all]" }, false), { _zone }, "c")

        for _, _unit in pairs(_unitsInZone) do
            local _unitGroup = Unit.getByName(_unit):getGroup()
            local _found = false
            for _i = 1, #groupsFound do
                if groupsFound[_i].name == _unitGroup:getName() then
                    _found = true
                end
            end

            if not _found then
                groupsFound[#groupsFound + 1] = _unitGroup
            end
        end

        return groupsFound
    end,
    -- Returns a count of all groups in a zone
    count = function(_zone)
        return #(Evac.groups.list(_zone))
    end,
}

--[[ --------------------------------------------------------------------- --
---- WE ALREADY SAID NOT TO EDIT THIS FILE, BUT ESPECIALLY NOT BELOW HERE! --
---- --------------------------------------------------------------------- ]]

-- Aircraft
Evac._internal.aircraft = {
    getZone = function(_unit)
        local _unitObj = Unit:getByName(_unit)

        if _unitObj ~= nil then
            local _unitPoint = _unitObj:getPoint()

            for _, _zoneData in pairs(Evac._state.zones.evac) do
                if mist.pointInZone(_unitPoint, _zoneData.name) then
                    return _zoneData.name
                end
            end

            for _, _zoneData in pairs(Evac._state.zones.relay) do
                if mist.pointInZone(_unitPoint, _zoneData.name) then
                    return _zoneData.name
                end
            end

            for _, _zoneData in pairs(Evac._state.zones.safe) do
                if mist.pointInZone(_unitPoint, _zoneData.name) then
                    return _zoneData.name
                end
            end
        end

        return nil
    end,
    inZone = function(_unit, _evacMode)
        return Evac._internal.zones.isIn(_unit, _evacMode)
    end,
    inAir = function(_unit)
        if type(_unit) == "string" then
            _unit = Unit.getByName(_unit)
        end

        -- Adapted from CTLD
        if _unit:inAir() == false then
            return false
        end

        if mist.vec.mag(_unit:getVelocity()) < 0.05 and _unit:getPlayerName() ~= nil then
            return false
        end

        return true
    end,
    heightDifference = function(_unit)
        if type(_unit) == "string" then
            _unit = Unit.getByName(_unit)
        end

        -- Adapted from CSAR and CTLD
        local _point = _unit:getPoint()
        return _point.y - land.getHeight({ x = _point.x, y = _point.z })
    end,
    loadEvacuees = function(_unit, _number)
        local _zone = Evac._internal.aircraft.getZone(_unit)
        local _timeout = Evac.loadUnloadPerIndividual * _number
        mist.scheduleFunction(
            function(_start)
                local _left = timer.getTime() - (_start + _timeout)
                local _message

                if _left <= 0 then
                    local _evacNameList
                    for _evacName, _ in pairs(Evac._state.extractableNow[_zone]) do
                        table.insert(_evacNameList, _evacName)
                    end

                    for _i = 1, _number do
                        local _randomName = _evacNameList[math.random(#_evacNameList)]
                        local _evacuee = Evac._state.extractableNow[_zone][_randomName]
                        table.insert(Evac._state.extractionUnits[_unit], _evacuee)
                    end

                    Evac._internal.aircraft.adaptWeight(_unit)
                    _message = "Evacuee loading complete!"
                else
                    _message = _left .. " seconds remaining in evacuee loading process"
                end

                Gremlin.displayMessageTo(_unit, _message, timer.getTime() + 1)
            end,
            { timer.getTime() + 1 },
            timer.getTime() + 1,
            1,
            _timeout
        )
    end,
    countEvacuees = function(_unit)
        return #(Evac._state.extractionUnits[_unit] or {})
    end,
    calculateWeight = function(_unit)
        local _calculated = 0

        if Gremlin.haveCSAR then
            ---@diagnostic disable-next-line: undefined-global
            _calculated = _calculated + (csar.weight * #(csar.inTransitGroups[_unit]))
        end

        if Gremlin.haveCTLD then
            ---@diagnostic disable-next-line: undefined-global
            _calculated = _calculated + ctld.getWeightOfCargo(_unit)
        end

        local _extracted = Evac._state.extractionUnits[_unit]

        if _extracted ~= nil then
            for _i, _evacuee in pairs(_extracted) do
                _calculated = _calculated + (_evacuee.weight or Evac._internal.utils.randomizeWeight(Evac.spawnWeight))
            end
        end

        return _calculated
    end,
    adaptWeight = function(_unit)
        -- Adapted from CTLD
        local _weight = Evac._internal.aircraft.calculateWeight(_unit)
        trigger.action.setUnitInternalCargo(_unit, _weight)
    end,
    unloadEvacuees = function(_unit)
        local _zone = Evac._internal.aircraft.getZone(_unit)
        local _number = Evac._internal.aircraft.countEvacuees(_unit)
        local _timeout = Evac.loadUnloadPerIndividual * _number

        mist.scheduleFunction(function(_start)
            local _left = timer.getTime() - (_start + _timeout)
            local _message

            if _left <= 0 then
                local _groups = {}
                for _, _evacuee in pairs(Evac._state.extractionUnits[_unit]) do
                    Evac._state.extractableNow[_zone][_evacuee.name] = _evacuee
                    _groups[Unit:getByName(_evacuee.name):getGroup():getName()] = true
                end

                for _groupName, _ in pairs(_groups) do
                    mist.teleportInZone(_groupName, _zone, true, 5)
                end

                Evac._state.extractionUnits[_unit] = {}
                Evac._internal.aircraft.adaptWeight(_unit)
                _message = "Evacuee unloading complete!"
            else
                _message = _left .. " seconds remaining in evacuee unloading process"
            end

            Gremlin.displayMessageTo(_unit, _message, timer.getTime() + 1)
        end, { timer.getTime() + 1 }, timer.getTime() + 1, 1, _timeout)
    end,
}

-- Beacons
Evac._internal.beacons = {
    spawn = function(_zone, _side, _country, _batteryLife, _name)
        if Gremlin.haveCTLD then
            ---@diagnostic disable-next-line: undefined-global
            return ctld.createRadioBeaconAtZone(_zone, _side, _batteryLife, _name)
        end

        if _name == nil or _name == "" then
            _name = "Beacon #" .. (#(Evac._state.beacons) + 1)
        end

        local _battery
        if _batteryLife == nil then
            _battery = timer.getTime() + (Evac.beaconBatteryLife * 60)
        else
            _battery = timer.getTime() + (_batteryLife * 60)
        end

        local _zonePos = mist.utils.zoneToVec3(_zone)
        local _groupId = Evac._internal.utils.getNextGroupId()
        local _unitId = Evac._internal.utils.getNextUnitId()
        local _freq = Evac._internal.beacons.getFreeADFFrequencies()
        local _freqsText = string.format("%.2f kHz - %.2f / %.2f MHz", (_freq.vhf or 30) / 1000, _freq.uhf / 1000000,
            _freq.fm / 1000000)

        local _radioGroup = {
            ["visible"] = false,
            ["hidden"] = false,
            ["units"] = {
                {
                    ["y"] = _zonePos.z,
                    ["type"] = "TACAN_beacon",
                    ["name"] = "VHF Unit #" .. _unitId .. " - " .. _name .. " [" .. _freqsText .. "]",
                    ["heading"] = 0,
                    ["playerCanDrive"] = true,
                    ["skill"] = "Excellent",
                    ["x"] = _zonePos.x,
                },
                {
                    ["y"] = _zonePos.z,
                    ["type"] = "TACAN_beacon",
                    ["name"] = "UHF Unit #" .. (_unitId + 1) .. " - " .. _name .. " [" .. _freqsText .. "]",
                    ["heading"] = 0,
                    ["playerCanDrive"] = true,
                    ["skill"] = "Excellent",
                    ["x"] = _zonePos.x,
                },
                {
                    ["y"] = _zonePos.z,
                    ["type"] = "TACAN_beacon",
                    ["name"] = "FM Unit #" .. (_unitId + 2) .. " - " .. _name .. " [" .. _freqsText .. "]",
                    ["heading"] = 0,
                    ["playerCanDrive"] = true,
                    ["skill"] = "Excellent",
                    ["x"] = _zonePos.x,
                },
            },
            ["name"] = "Group #" .. _groupId .. " - " .. _name,
            ["task"] = {},
            ["category"] = Group.Category.GROUND,
            ["country"] = _country
        }

        mist.dynAdd(_radioGroup)

        local _beaconDetails = {
            vhf = _freq.vhf,
            uhf = _freq.uhf,
            fm = _freq.fm,
            group = _radioGroup.name,
            text = _freqsText,
            battery = _battery,
            side = _side,
        }

        Evac._internal.beacons.update(_beaconDetails)
        table.insert(Evac._state.beacons, _beaconDetails)

        return _beaconDetails
    end,
    getFreeADFFrequencies = function()
        if #Evac._state.frequencies.uhf.free <= 0 then
            Evac._state.frequencies.uhf.free = Evac._state.frequencies.uhf.used
            Evac._state.frequencies.uhf.used = {}
        end

        local _uhf = table.remove(Evac._state.frequencies.uhf.free, math.random(1, #Evac._state.frequencies.uhf.free))
        table.insert(Evac._state.frequencies.uhf.used, _uhf)


        if #Evac._state.frequencies.vhf.free <= 0 then
            Evac._state.frequencies.vhf.free = Evac._state.frequencies.vhf.used
            Evac._state.frequencies.vhf.used = {}
        end

        local _vhf = table.remove(Evac._state.frequencies.vhf.free, math.random(1, #Evac._state.frequencies.vhf.free))
        table.insert(Evac._state.frequencies.vhf.used, _vhf)

        if #Evac._state.frequencies.fm.free <= 0 then
            Evac._state.frequencies.fm.free = Evac._state.frequencies.fm.used
            Evac._state.frequencies.fm.used = {}
        end

        local _fm = table.remove(Evac._state.frequencies.fm.free, math.random(1, #Evac._state.frequencies.fm.free))
        table.insert(Evac._state.frequencies.fm.used, _fm)

        return { uhf = _uhf, vhf = _vhf, fm = _fm }
    end,
    list = function(_unit)
        local _message

        if _unit ~= nil and type(_unit) == "string" then
            local _unitObj = mist.DBs.unitsByName[_unit]

            if _unitObj ~= nil then
                for _x, _details in pairs(Evac._state.beacons) do
                    if _details.side == _unitObj:getCoalition() then
                        _message = string.format("%s%s (%s)\n", _message or "", _details.group, _details.text or "")
                    end
                end

                if _message ~= nil and _message ~= "" then
                    Gremlin.displayMessageTo(_unitObj:getGroup(), "Radio Beacons:\n" .. _message, 20)
                else
                    Gremlin.displayMessageTo(_unitObj:getGroup(), "No Active Radio Beacons", 20)
                end
            end
        end
    end,
    update = function(_beaconDetails)
        local _radioGroup = Group.getByName(_beaconDetails.group)
        if _radioGroup == nil then
            return false
        end

        local _batteryLife = _beaconDetails.battery - timer.getTime()
        if _batteryLife < 1 and _beaconDetails.battery ~= -1 then
            trigger.action.stopRadioTransmission(_beaconDetails.text .. " | VHF")
            trigger.action.stopRadioTransmission(_beaconDetails.text .. " | UHF")
            trigger.action.stopRadioTransmission(_beaconDetails.text .. " | FM")
            _radioGroup:destroy()

            return false
        end

        local _controller = _radioGroup:getController()
        local _sound = "l10n/DEFAULT/" .. Evac.beaconSound

        _controller:setOption(AI.Option.Ground.id.ROE, AI.Option.Ground.val.ROE.WEAPON_HOLD)

        trigger.action.stopRadioTransmission(_beaconDetails.text .. " | VHF")
        trigger.action.stopRadioTransmission(_beaconDetails.text .. " | UHF")
        trigger.action.stopRadioTransmission(_beaconDetails.text .. " | FM")
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(1):getPoint(), 0, true, _beaconDetails.vhf, 1000, _beaconDetails.text .. " | VHF")
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(2):getPoint(), 0, true, _beaconDetails.uhf, 1000, _beaconDetails.text .. " | UHF")
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(3):getPoint(), 1, true, _beaconDetails.fm, 1000, _beaconDetails.text .. " | FM")

        return true
    end,
    killDead = function()
        if Gremlin.haveCTLD then
            return ctld.refreshRadioBeacons()
        end

        timer.scheduleFunction(Evac._internal.beacons.killDead, nil, timer.getTime() + 60)

        for _index, _beaconDetails in ipairs(Evac._state.beacons) do
            if _beaconDetails.battery - timer.getTime() <= 0 and _beaconDetails.battery ~= -1 then
                for _i, _freq in ipairs(Evac._state.frequencies.uhf.used) do
                    if _freq == _beaconDetails.uhf then
                        table.insert(Evac._state.frequencies.uhf.free, _freq)
                        table.remove(Evac._state.frequencies.uhf.used, _i)
                    end
                end

                for _i, _freq in ipairs(Evac._state.frequencies.vhf.used) do
                    if _freq == _beaconDetails.vhf then
                        table.insert(Evac._state.frequencies.vhf.free, _freq)
                        table.remove(Evac._state.frequencies.vhf.used, _i)
                    end
                end

                for _i, _freq in ipairs(Evac._state.frequencies.fm.used) do
                    if _freq == _beaconDetails.fm then
                        table.insert(Evac._state.frequencies.fm.free, _freq)
                        table.remove(Evac._state.frequencies.fm.used, _i)
                    end
                end

                table.remove(Evac._state.beacons, _index)
            end
        end
    end,
    generateVHFrequencies = function()
        local _skipFrequencies = {
            745, --Astrahan
            381,
            384,
            300.50,
            312.5,
            1175,
            342,
            735,
            300.50,
            353.00,
            440,
            795,
            525,
            520,
            690,
            625,
            291.5,
            300.50,
            435,
            309.50,
            920,
            1065,
            274,
            312.50,
            580,
            602,
            297.50,
            750,
            485,
            950,
            214,
            1025, 730, 995, 455, 307, 670, 329, 395, 770,
            380, 705, 300.5, 507, 740, 1030, 515,
            330, 309.5,
            348, 462, 905, 352, 1210, 942, 435,
            324,
            320, 420, 311, 389, 396, 862, 680, 297.5,
            920, 662,
            866, 907, 309.5, 822, 515, 470, 342, 1182, 309.5, 720, 528,
            337, 312.5, 830, 740, 309.5, 641, 312, 722, 682, 1050,
            1116, 935, 1000, 430, 577,
            326 -- Nevada
        }

        Evac._state.frequencies.vhf.free = {}
        local _start = 200000

        while _start < 400000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 10000
        end

        _start = 400000
        while _start < 850000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 10000
        end

        _start = 850000
        while _start <= 1250000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 50000
        end
    end,
    generateUHFrequencies = function()
        Evac._state.frequencies.uhf.free = {}
        local _start = 220000000

        while _start < 399000000 do
            table.insert(Evac._state.frequencies.uhf.free, _start)
            _start = _start + 500000
        end
    end,
    generateFMFrequencies = function()
        Evac._state.frequencies.fm.free = {}
        local _start = 220000000

        while _start < 399000000 do
            _start = _start + 500000
        end

        for _first = 3, 7 do
            for _second = 0, 5 do
                for _third = 0, 9 do
                    for _fourth = 0, 1 do
                        local _frequency = ((1000 * _first) + (100 * _second) + (10 * _third) + (5 * _fourth)) * 10000
                        table.insert(Evac._state.frequencies.fm.free, _frequency)
                    end
                end
            end
        end
    end,
}

-- Smoke
Evac._internal.smoke = {
    refresh = function()
        for _, _zoneData in pairs(Gremlin.mergeTables(Evac._state.zones.evac, Evac._state.zones.relay, Evac._state.zones.safe)) do
            local _zone = trigger.misc.getZone(_zoneData.name)
            if _zone ~= nil and _zoneData.active then
                local _pos2 = { x = _zone.point.x, y = _zone.point.z }
                local _alt = land.getHeight(_pos2)
                local _pos3 = { x = _pos2.x, y = _alt, z = _pos2.y }

                trigger.action.smoke(_pos3, _zoneData.smoke)
            end
        end

        timer.scheduleFunction(Evac._internal.smoke.refresh, nil, timer.getTime() + 300)
    end,
}

-- Zones
Evac._internal.zones = {
    register = function(_zone, _smoke, _side, _evacMode)
        Evac._state.zones[Evac.modeToText[_evacMode]][_zone] = {
            active = false,
            name = _zone,
            side = _side,
            smoke = _smoke,
            mode = _evacMode,
        }
        Evac._state.extractableNow[_zone] = {}
    end,
    generateEvacuees = function(_side, _numberOrComposition, _country)
        local _groupName = "Evacuee Group"
        local _unitType = "Refugee"
        local _groupId = Evac._internal.utils.getNextGroupId()
        local _composition = {}
        local _troops = {}
        local _weight = 0

        if type(_numberOrComposition) == "number" then
            for _i = 1, _numberOrComposition do
                _composition[_i] = { type = _unitType }
            end
        else
            _composition = _numberOrComposition or {}
        end

        for _i, _unit in ipairs(_composition) do
            if _unit.type == nil then
                _unit.type = _unitType
            end
            if _unit.unitId == nil then
                _unit.unitId = Evac._internal.utils.getNextUnitId() + (_i - 1)
            end
            if _unit.unitName == nil then
                _unit.unitName = string.format("Evacuee: %s #%i", _unit.type, _unit.unitId)
            end
            if _unit.weight == nil then
                _unit.weight = Evac._internal.utils.randomizeWeight(Evac.spawnWeight)
            end

            _troops[_i] = _unit
            _weight = _weight + _unit.weight
        end

        return {
            units = _troops,
            groupId = _groupId,
            groupName = string.format("%s %i", _groupName, _groupId),
            side = _side,
            country = _country,
            weight = _weight,
        }
    end,
    activate = function(_zone, _evacMode)
        Evac._state.zones[Evac.modeToText[_evacMode]][_zone].active = true
    end,
    setRemaining = function(_zone, _side, _country, _numberOrComposition)
        for _unitName, _unit in pairs(Evac._state.extractableNow[_zone]) do
            if not Evac._internal.aircraft.inZone(_unitName, _zone) then
                local _newZone = Evac._internal.aircraft.getZone(_unitName)

                if _newZone ~= nil and Evac._state.extractableNow[_newZone] ~= nil then
                    Evac._state.extractableNow[_newZone][_unitName] = _unit
                end
            else
                Unit.getByName(_unitName):destroy()
            end

            Evac._state.extractableNow[_zone][_unitName] = nil
        end

        Evac.groups.spawn(_side, _numberOrComposition, _country, _zone, 5)
    end,
    count = function(_zone, _evacMode)
        local _count = 0

        if Evac._state.zones[Evac.modeToText[_evacMode]][_zone] ~= nil then
            for _, _ in pairs(Evac._state.extractableNow[_zone]) do
                _count = _count + 1
            end
        end

        return _count
    end,
    isIn = function(_unit, _evacMode)
        local _unitObj = Unit.getByName(_unit)

        if _unitObj ~= nil then
            if type(_evacMode) == "string" then
                local _zone = _evacMode
                local _zoneData = Evac._state.zones.evac[_zone] or Evac._state.zones.relay[_zone] or Evac._state.zones.safe[_zone] or { active = false }
                local _unitPoint = _unitObj:getPoint()

                return _zoneData.active and mist.pointInZone(_unitPoint, _zone)
            else
                for _, _zoneData in pairs(Evac._state.zones[Evac.modeToText[_evacMode]]) do
                    if _zoneData.active and mist.pointInZone(_unitObj:getPoint(), _zoneData.name) then
                        return true
                    end
                end
            end
        end

        return false
    end,
    deactivate = function(_zone, _evacMode)
        Evac._state.zones[Evac.modeToText[_evacMode]][_zone].active = false
    end,
    unregister = function(_zone, _evacMode)
        for _unit, _ in pairs(Evac._state.extractableNow[_zone]) do
            Unit.getByName(_unit):destroy()
        end

        Evac._state.extractableNow[_zone] = nil
        Evac._state.zones[Evac.modeToText[_evacMode]][_zone] = nil
    end,
}

-- Menu
Evac._internal.menu = {
    addToF10 = function()
        timer.scheduleFunction(Evac._internal.menu.addToF10, nil, timer.getTime() + 10)

        for _unitName, _ in pairs(Evac._state.extractionUnits) do
            local _unit = Unit.getByName(_unitName)
            local _groupId = _unit:getGroup().groupId

            local _rootPath
            if Evac._state.menuAdded[_groupId] == nil then
                _rootPath = missionCommands.addSubMenuForGroup(_groupId, "Gremlin Evac")
                Evac._state.menuAdded[_groupId] = { root = _rootPath }
            else
                _rootPath = Evac._state.menuAdded[_groupId].root
            end

            for _cmdIdx, _command in pairs(Evac._internal.menu.commands) do
                local _when = false
                if type(_command.when) == "boolean" then
                    _when = _command.when
                elseif type(_command.when) == "table" then
                    local _whenArgs = Gremlin.parseFuncArgs(_command.when.args, { unit = _unit, group = _unit:getGroup() })

                    if _command.when.func(_whenArgs) == _command.when.value and _command.when.comp == "equal" then
                        _when = true
                    end
                end

                missionCommands.removeItemForGroup(_groupId, Evac._state.menuAdded[_groupId][_cmdIdx])

                local _args = Gremlin.parseFuncArgs(_command.args, { unit = _unit, group = _unit:getGroup() })
                if _when then
                    Evac._state.menuAdded[_groupId][_cmdIdx] = missionCommands.addCommandForGroup(_groupId, _command .text, _rootPath, _command.func, _args)
                end
            end
        end
    end,
    commands = {
        {
            text = "Scan For Evacuee Beacons",
            func = Evac.units.findEvacuees,
            args = { "{unit}:name" },
            when = true,
        },
        {
            text = "Load Evacuees",
            func = Evac.units.loadEvacuees,
            args = { "{unit}:name" },
            when = {
                func = Evac._internal.aircraft.countEvacuees,
                args = { "{unit}:name" },
                comp = "equal",
                value = 0,
            },
        },
        {
            text = "Unload Evacuees",
            func = Evac.units.unloadEvacuees,
            args = { "{unit}:name" },
            when = {
                func = Evac._internal.aircraft.countEvacuees,
                args = { "{unit}:name" },
                comp = "inequal",
                value = 0,
            },
        },
        {
            text = "Evacuees Aboard",
            func = Evac.units.countEvacuees,
            args = { "{unit}:name" },
            when = true,
        },
    },
}

-- Utilities
Evac._internal.utils = {
    currentGroup = Evac.idStart + 1,
    currentUnit = Evac.idStart + 1,
    getNextGroupId = function()
        if Gremlin.haveCTLD then
            Evac._internal.utils.currentGroup = ctld.getNextGroupId() + Evac.idStart
        else
            Evac._internal.utils.currentGroup = mist.getNextGroupId() + Evac.idStart
        end

        return Evac._internal.utils.currentGroup
    end,
    getNextUnitId = function()
        if Gremlin.haveCTLD then
            Evac._internal.utils.currentUnit = ctld.getNextUnitId() + Evac.idStart
        else
            Evac._internal.utils.currentUnit = mist.getNextUnitId() + Evac.idStart
        end

        return Evac._internal.utils.currentUnit
    end,
    randomizeWeight = function(_weight)
        return (math.random(90, 120) * (_weight or Evac.spawnWeight)) / 100
    end,
    unitDataToList = function(_units, _point, _scatterRadius)
        local _unitsOut = {}
        ---@diagnostic disable-next-line: deprecated
        local _angle = math.atan2(_point.z, _point.x)
        local _xOffset = math.cos(_angle) * -30
        local _yOffset = math.sin(_angle) * -30

        for _i, _unit in pairs(_units) do
            _unitsOut[_i] = {
                type = _unit.type,
                unitId = _unit.unitId,
                name = _unit.unitName,
                skill = "Excellent",
                playerCanDrive = false,
                x = _point.x + (_xOffset + math.random(_scatterRadius)),
                y = _point.z + (_yOffset + math.random(_scatterRadius)),
                heading = _angle,
            }
        end

        return _unitsOut
    end,
}

-- Event handler
function Evac:onEvent(_event)
    Gremlin.logInfo(Evac.Id, string.format("EVENT: %s\n", tostring(_event)))

    -- // TODO
end

--[[
Setup Gremlin Evac! The argument should contain a configuration table as
shown below.

Example providing all the defaults:

```
Evac:setup({
    beaconBatteryLife = 30,
    beaconSound = "beacon.ogg",
    carryLimits = {
        ["C-130"] = 90,
        ["CH-47D"] = 44,
        ["CH-43E"] = 55,
        ["Mi-8MT"] = 24,
        ["Mi-24P"] = 5,
        ["Mi-24V"] = 5,
        ["Mi-26"] = 70,
        ["SH-60B"] = 5,
        ["UH-1H"] = 8,
        ["UH-60A"] = 11,
    },
    idStart = 500,
    loadUnloadPerIndividual = 30,
    maxExtractable = {
        Refugees = 0,
        Infantry = 0,
        M249 = 0,
        RPG = 0,
        StingerIgla = 0,
        ["2B11"] = 0,
        JTAC = 0,
        Downed = 0,
    },
    spawnRates = {
        _global = {
            units = 0, -- 0 loads all; + adds, - subtracts
            per = 0,   -- 0 means only at launch; + every, - once after
            period = Gremlin.Periods.Second,
        },
    },
    spawnWeight = 100,
    startingZones = {},
})
```

`spawnRates` is a table whose keys are zone names, with one special zone
called `_global` that applies to the entire map. Each value is a table listing
the number of units to generate, and how long to wait between spawns. In English,
it would probably be described as "{units} unit(s) every {per} {period}(s)".
The special value 0 for `units` means "as many as allowed"; negative values
actually remove evacuees according to the same rules. `period` should be a
constant from `Gremlin.Periods`. `per` indicates how many periods to wait
between auto spawns; the special value 0 means "mission start", while positive
values run every `per` `period`s, and negative means only spawn once rather
than repeatedly.

`startingZones` is also keyed by zone name, but the contents describe the
zone(s) themselves. Four keys are required: `mode` (one of the constants in
`Evac.modes`), `name`, `smoke` (one of the constants in
`trigger.smokeColor`), and `side` (the coalition number this zone should be
attached to).
]]
function Evac:setup(config)
    assert(Gremlin ~= nil,
        "\n\n** HEY MISSION-DESIGNER! **\n\nGremlin Script Tools has not been loaded!\n\nMake sure Gremlin Script Tools is running *before* running this script!\n")

    if not Gremlin.alreadyInitialized or config.forceReload then
        Gremlin:setup(config)
    end

    if Evac._state.alreadyInitialized and not config.forceReload then
        Gremlin.logInfo(Evac.Id, string.format("Bypassing initialization because Evac._state.alreadyInitialized = true"))
        return
    end

    if config ~= nil then
        Evac.beaconBatteryLife = config.beaconBatteryLife or 30
        Evac.beaconSound = config.beaconSound or "beacon.ogg"
        Evac.carryLimits = config.carryLimits or {
            ["C-130"] = 90,
            ["CH-47D"] = 44,
            ["CH-43E"] = 55,
            ["Mi-8MT"] = 24,
            ["Mi-24P"] = 5,
            ["Mi-24V"] = 5,
            ["Mi-26"] = 70,
            ["SH-60B"] = 5,
            ["UH-1H"] = 8,
            ["UH-60A"] = 11,
        }
        Evac.idStart = config.idStart or 500
        Evac.loadUnloadPerIndividual = config.loadUnloadPerIndividual or 30

        if config.maxExtractable ~= nil then
            Evac.maxExtractable.Refugees = config.maxExtractable.Refugees or 0
            Evac.maxExtractable.Infantry = config.maxExtractable.Infantry or 0
            Evac.maxExtractable.M249 = config.maxExtractable.M249 or 0
            Evac.maxExtractable.RPG = config.maxExtractable.RPG or 0
            Evac.maxExtractable.StingerIgla = config.maxExtractable.StingerIgla or 0
            Evac.maxExtractable["2B11"] = config.maxExtractable["2B11"] or 0
            Evac.maxExtractable.JTAC = config.maxExtractable.JTAC or 0
        end

        Evac.spawnWeight = config.spawnWeight or 100
        Evac.spawnRates = config.spawnRates or {
            _global = {
                units = 0, -- 0 loads all; + adds, - subtracts
                per = 0,   -- 0 means only at launch; + every, - once after
                period = Gremlin.Periods.Second,
            },
        }

        if config.startingZones ~= nil then
            for _, _zone in pairs(config.startingZones) do
                if Evac.modeToText[_zone.mode] ~= nil then
                    Evac.zones[Evac.modeToText[_zone.mode]].create(_zone.name, _zone.smoke, _zone.side)
                else
                    Gremlin.logError("Can't find " .. Gremlin.SideToText[_zone.side] .. " zone " .. _zone.name)
                end
            end
        end
    end

    Evac._internal.beacons.generateVHFrequencies()
    Evac._internal.beacons.generateUHFrequencies()
    Evac._internal.beacons.generateFMFrequencies()

    timer.scheduleFunction(function()
        timer.scheduleFunction(Evac._internal.beacons.killDead, nil, timer.getTime() + 5)
        timer.scheduleFunction(Evac._internal.smoke.refresh, nil, timer.getTime() + 5)
        timer.scheduleFunction(Evac._internal.menu.addToF10, nil, timer.getTime() + 5)
    end, nil, timer.getTime() + 1)

    mist.addEventHandler(Evac._internal.onEvent)

    Evac._state.alreadyInitialized = true
end
