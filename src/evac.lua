--[[
DO NOT EDIT THIS FILE! Things WILL break that way.

Instead!

When calling `Evac:setup()`, you can pass in a configuration table instead
of `nil`. Make your changes in the table you pass - defaults are already in
place if you want to leave those out.

An example, providing all the defaults, is available near the end of this script.
]]
Evac = {
    -- Static Info

    -- Contains an identifier for this script
    Id = 'Gremlin Evac',
    -- Contains the current script version
    Version = '202403.01',

    -- Config

    -- How long a beacon should last, in minutes
    beaconBatteryLife = 0,
    -- The audio file to play for beacons
    beaconSound = '',
    -- The max carrying capacity of the aircraft in this misson
    -- Table should be a list of capacities keyed by the unit type name
    carryLimits = {},
    -- Where to start counting when generating new units' and groups' IDs
    idStart = 0,
    -- How long it takes to load one unit, in seconds
    loadUnloadPerIndividual = 0,
    -- The Mission Editor flags to set when the players lose too many forces
    lossFlags = {0, 0},
    -- The percentage of evacuees that can be lost before mission loss
    lossThresholds = {0, 0},
    -- The maximum number of each unit to generate when spawning units
    maxExtractable = {{
        ['Ejected Pilot'] = 0,
        Infantry = 0,
        M249 = 0,
        RPG = 0,
        StingerIgla = 0,
        ['2B11'] = 0,
        JTAC = 0
    }, {
        ['Ejected Pilot'] = 0,
        Infantry = 0,
        M249 = 0,
        RPG = 0,
        StingerIgla = 0,
        ['2B11'] = 0,
        JTAC = 0
    }},
    -- How frequently to spawn new units, per zone
    spawnRates = {},
    -- The default weight of new units; exact weights will vary by unit
    spawnWeight = 0,
    -- The Mission Editor flags to set when the players evacuate enough forces
    winFlags = {0, 0},
    -- The percentage of evacuees that must be rescued before mission win
    winThresholds = {0, 0},

    -- Enums

    -- The modes that a zone can be in
    modes = {
        EVAC = 1,
        SAFE = 2,
        RELAY = 3
    },
    -- Lookup table for modes to names
    modeToText = {'evac', 'safe', 'relay'},

    -- Internals - DO NOT USE / MODIFY

    -- Internal Methods - AVOID USING / DO NOT MODIFY
    _internal = {},
    -- Internal State - DO NOT USE / MODIFY
    _state = {
        alreadyInitialized = false,
        beacons = {},
        extractableNow = {},
        extractionUnits = {},
        frequencies = {
            uhf = {
                free = {},
                used = {}
            },
            vhf = {
                free = {},
                used = {}
            },
            fm = {
                free = {},
                used = {}
            }
        },
        lostEvacuees = {{
            ['Ejected Pilot'] = 0,
            Infantry = 0,
            M249 = 0,
            RPG = 0,
            StingerIgla = 0,
            ['2B11'] = 0,
            JTAC = 0
        }, {
            ['Ejected Pilot'] = 0,
            Infantry = 0,
            M249 = 0,
            RPG = 0,
            StingerIgla = 0,
            ['2B11'] = 0,
            JTAC = 0
        }},
        menuAdded = {},
        smoke = {},
        spawns = {
            alreadySpawned = {{
                ['Ejected Pilot'] = 0,
                Infantry = 0,
                M249 = 0,
                RPG = 0,
                StingerIgla = 0,
                ['2B11'] = 0,
                JTAC = 0
            }, {
                ['Ejected Pilot'] = 0,
                Infantry = 0,
                M249 = 0,
                RPG = 0,
                StingerIgla = 0,
                ['2B11'] = 0,
                JTAC = 0
            }},
            lastChecked = {}
        },
        zones = {
            evac = {},
            relay = {},
            safe = {}
        }
    }
}

-- Methods

--- Zone methods
Evac.zones = {
    -- Evac Zone methods
    evac = {
        -- Mark a zone as part of the Evac ecosystem, and give it the evac mode
        register = function(_zone, _smoke, _side)
            Gremlin.log.trace(Evac.Id, string.format('Registering Evac Zone : %s, %i, %i', _zone, _smoke, _side))

            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.EVAC)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Activating Evac Zone : %s', _zone))

            return Evac._internal.zones.activate(_zone, Evac.modes.EVAC)
        end,
        -- Manually override the remaining units in a zone
        setRemaining = function(_zone, _side, _country, _numberOrComposition)
            if type(_numberOrComposition) == "table" then
                Gremlin.log.trace(Evac.Id,
                    string.format('Setting Remaining In Evac Zone : %s, %i, %i, %s', _zone, _side, _country,
                        mist.utils.tableShowSorted(_numberOrComposition)))
            else
                Gremlin.log.trace(Evac.Id, string.format('Setting Remaining In Evac Zone : %s, %i, %i, %i', _zone,
                    _side, _country, _numberOrComposition))
            end

            return Evac._internal.zones.setRemaining(_zone, _side, _country, _numberOrComposition)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees In Evac Zone : %s', _zone))

            return Evac._internal.zones.count(_zone, Evac.modes.EVAC)
        end,
        -- Check whether a given unit is in an evac zone
        isIn = function(_unit)
            Gremlin.log.trace(Evac.Id, string.format('Checking For Unit In Evac Zones : %s', _unit))

            return Evac._internal.zones.isIn(_unit, Evac.modes.EVAC)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Deactivating Evac Zone : %s', _zone))

            return Evac._internal.zones.deactivate(_zone, Evac.modes.EVAC)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Unregistering Evac Zone : %s', _zone))

            return Evac._internal.zones.unregister(_zone, Evac.modes.EVAC)
        end
    },
    -- Relay Zone methods
    relay = {
        -- Mark a zone as part of the Evac ecosystem, and give it the relay mode
        register = function(_zone, _smoke, _side)
            Gremlin.log.trace(Evac.Id, string.format('Registering Relay Zone : %s, %i, %i', _zone, _smoke, _side))

            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.RELAY)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Activating Relay Zone : %s', _zone))

            return Evac._internal.zones.activate(_zone, Evac.modes.RELAY)
        end,
        -- Manually override the remaining units in a zone
        setRemaining = function(_zone, _side, _country, _numberOrComposition)
            if type(_numberOrComposition) == "table" then
                Gremlin.log.trace(Evac.Id,
                    string.format('Setting Remaining In Relay Zone : %s, %i, %i, %s', _zone, _side, _country,
                        mist.utils.tableShowSorted(_numberOrComposition)))
            else
                Gremlin.log.trace(Evac.Id, string.format('Setting Remaining In Relay Zone : %s, %i, %i, %i', _zone,
                    _side, _country, _numberOrComposition))
            end

            return Evac._internal.zones.setRemaining(_zone, _side, _country, _numberOrComposition)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees In Relay Zone : %s', _zone))

            return Evac._internal.zones.count(_zone, Evac.modes.RELAY)
        end,
        -- Check whether a given unit is in a relay zone
        isIn = function(_unit)
            Gremlin.log.trace(Evac.Id, string.format('Checking For Unit In Relay Zones : %s', _unit))

            return Evac._internal.zones.isIn(_unit, Evac.modes.RELAY)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Deactivating Relay Zone : %s', _zone))

            return Evac._internal.zones.deactivate(_zone, Evac.modes.RELAY)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Unregistering Relay Zone : %s', _zone))

            return Evac._internal.zones.unregister(_zone, Evac.modes.RELAY)
        end
    },
    -- Safe Zone methods
    safe = {
        -- Mark a zone as part of the Evac ecosystem, and give it the safe mode
        register = function(_zone, _smoke, _side)
            Gremlin.log.trace(Evac.Id, string.format('Registering Safe Zone : %s, %i, %i', _zone, _smoke, _side))

            return Evac._internal.zones.register(_zone, _smoke, _side, Evac.modes.SAFE)
        end,
        -- Activate a zone for evacuation operations
        activate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Activating Safe Zone : %s', _zone))

            return Evac._internal.zones.activate(_zone, Evac.modes.SAFE)
        end,
        -- Count the number of evacuees in a zone
        count = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Count Evacuees In Safe Zone : %s', _zone))

            return Evac._internal.zones.count(_zone, Evac.modes.SAFE)
        end,
        -- Check whether a given unit is in a safe zone
        isIn = function(_unit)
            Gremlin.log.trace(Evac.Id, string.format('Checking For Unit In Safe Zones : %s', _unit))

            return Evac._internal.zones.isIn(_unit, Evac.modes.SAFE)
        end,
        -- Deactivate a zone for evacuation operations
        deactivate = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Deactivating Safe Zone : %s', _zone))

            return Evac._internal.zones.deactivate(_zone, Evac.modes.SAFE)
        end,
        -- Forget a zone once it should no longer be used as part of the Evac ecosystem
        unregister = function(_zone)
            Gremlin.log.trace(Evac.Id, string.format('Unregistering Safe Zone : %s', _zone))

            return Evac._internal.zones.unregister(_zone, Evac.modes.SAFE)
        end
    }
}

--- Unit methods
Evac.units = {
    -- Registers a unit as an evacuation unit, capable of performing evacutions
    register = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Registering Unit As Evacuation Unit : %s', tostring(_unit)))

        local _unitObj

        if type(_unit) == 'table' and _unit.getName ~= nil then
            _unitObj = _unit
            _unit = _unitObj:getName()
        else
            _unitObj = Unit.getByName(_unit)
        end

        Evac._state.extractionUnits[_unit] = {
            [0] = _unitObj
        }
    end,
    -- Lists the currently active beacons broadcasting for the player's coalition
    findEvacuees = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Searching For Evacuation Beacons : %s', tostring(_unit)))

        Evac._internal.beacons.list(_unit)
    end,
    -- Starts the evacuee loading process for a unit
    loadEvacuees = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Starting Evacuee Loading Process : %s', _unit))

        local _unitObj = Unit.getByName(_unit)
        if _unitObj ~= nil then
            local _free = Evac.carryLimits[_unitObj:getTypeName()] or 0
            if _free == 0 then
                Gremlin.utils.displayMessageTo(_unit, "Your aircraft isn't rated for evacuees in this mission!", 1)
                return
            end

            _free = _free - Evac._internal.aircraft.countEvacuees(_unit)
            if _free <= 0 then
                Gremlin.utils.displayMessageTo(_unit, 'Already full! Unload, first!', 1)
                return
            end

            Evac._internal.aircraft.loadEvacuees(_unit, _free)
        else
            Gremlin.utils.displayMessageTo(_unit, "Your aircraft isn't rated for evacuees in this mission!", 1)
        end
    end,
    -- Starts the evacuee unloading process for a unit
    unloadEvacuees = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Starting Evacuee Unloading Process : %s', _unit))

        Evac._internal.aircraft.unloadEvacuees(_unit)
    end,
    -- Count the number of evacuees on board a given unit
    countEvacuees = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees Aboard : %s', _unit))

        local _count = Evac._internal.aircraft.countEvacuees(_unit)

        Gremlin.utils.displayMessageTo(_unit, 'You are currently carrying ' .. _count .. ' evacuees.', 1)
    end,
    -- Count the number of units in a given zone
    count = function(_zone)
        Gremlin.log.trace(Evac.Id, string.format('Counting Units In Zone : %s', _zone))

        return #(mist.getUnitsInZones(mist.makeUnitTable({'[all]'}, false), {_zone}, 'c'))
    end,
    -- Registers a unit as an evacuation unit, capable of performing evacutions
    unregister = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Unregistering Unit As Evacuation Unit : %s', tostring(_unit)))

        if type(_unit) == 'table' and _unit.getName ~= nil then
            _unit = _unit:getName()
        end

        Evac._state.extractionUnits[_unit] = nil
    end
}

--- Group methods
Evac.groups = {
    -- Spawns generic evacuees when given a number for `_numberOrComposition`.
    -- For a mix of evac targets, pass a list of units to add instead.
    spawn = function(_side, _numberOrComposition, _country, _zone, _scatterRadius)
        if type(_numberOrComposition) == 'table' then
            Gremlin.log.trace(Evac.Id, string.format('Spawning New Evacuee Group : %i, %s, %i, %s, %i', _side, mist.utils.tableShowSorted(_numberOrComposition), _country, _zone, _scatterRadius))
        else
            Gremlin.log.trace(Evac.Id, string.format('Spawning New Evacuee Group : %i, %i, %i, %s, %i', _side, _numberOrComposition, _country, _zone, _scatterRadius))
        end

        local _groupData = Evac._internal.zones.generateEvacuees(_side, _numberOrComposition, _country)
        local _spawnZone = trigger.misc.getZone(_zone)

        if _spawnZone == nil then
            trigger.action.outText("GREMLIN EVAC ERROR: Can't find zone called " .. _zone, 10)
            return
        end

        if _scatterRadius < 5 then
            _scatterRadius = 5
        end

        local _pos2 = {
            x = _spawnZone.point.x,
            y = _spawnZone.point.z
        }
        local _alt = land.getHeight(_pos2)
        local _pos3 = {
            x = _pos2.x,
            y = _alt,
            z = _pos2.y
        }

        local _group = {
            visible = false,
            hidden = true,
            units = Evac._internal.utils.unitDataToList(_groupData.units, _pos3, _scatterRadius),
            name = _groupData.groupName,
            groupId = _groupData.groupId,
            category = Group.Category.GROUND,
            country = _groupData.country,
            x = _pos3.x,
            y = _pos3.z,
        }

        mist.dynAdd(_group)
        -- trigger.action.activateGroup(_group.name)
        -- mist.teleportInZone(_group.name, _zone, true, _scatterRadius)

        for _, _unit in pairs(_groupData.units) do
            Evac._state.extractableNow[_zone][_unit.unitName] = _unit
        end

        Evac._internal.beacons.spawn(_zone, _side, _country)

        return _group
    end,
    -- Returns a list of all groups in a zone
    list = function(_zone)
        Gremlin.log.trace(Evac.Id, string.format('Listing Groups In Zone : %s', _zone))

        local groupsFound = {}
        local _unitsInZone = mist.getUnitsInZones(mist.makeUnitTable({'[all]'}, false), {_zone}, 'c')

        for _, _unit in pairs(_unitsInZone) do
            local _unitGroup = Unit.getByName(_unit):getGroup()
            local _found = false
            for _i = 1, #groupsFound do
                if groupsFound[_i].name == _unitGroup:getName() then
                    _found = true
                end
            end

            if not _found then
                groupsFound[#groupsFound + 1] = _unitGroup
            end
        end

        return groupsFound
    end,
    -- Returns a count of all groups in a zone
    count = function(_zone)
        Gremlin.log.trace(Evac.Id, string.format('Counting Groups In Zone : %s', _zone))

        return #(Evac.groups.list(_zone))
    end
}

--[[ --------------------------------------------------------------------- --
---- WE ALREADY SAID NOT TO EDIT THIS FILE, BUT ESPECIALLY NOT BELOW HERE! --
---- --------------------------------------------------------------------- ]]

-- Aircraft
Evac._internal.aircraft = {
    getZone = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Grabbing Unit Zone Name : %s', _unit))

        local _unitObj = Unit.getByName(_unit)

        if _unitObj ~= nil then
            local _unitPoint = _unitObj:getPoint()

            for _, _zoneData in pairs(Gremlin.utils.mergeTables(Evac._state.zones.evac, Evac._state.zones.relay, Evac._state.zones.safe)) do
                if mist.pointInZone(_unitPoint, _zoneData.name) then
                    return _zoneData.name
                end
            end
        end

        return nil
    end,
    inZone = function(_unit, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Checking For Unit In Zones : %s, %s', _unit, tostring(_evacMode)))

        return Evac._internal.zones.isIn(_unit, _evacMode)
    end,
    inAir = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Checking Whether Unit Is In Air : %s', tostring(_unit)))

        if type(_unit) == 'string' then
            _unit = Unit.getByName(_unit)
        end

        if _unit:inAir() == false then
            Gremlin.log.trace(Evac.Id, string.format('DCS Says Not In Air : %s', _unit:getName()))

            return false
        end

        if mist.vec.mag(_unit:getVelocity()) < 0.05 and _unit:getPlayerName() ~= nil then
            Gremlin.log.trace(Evac.Id, string.format('Moving Too Slow (Not In Air) : %s', _unit:getName()))

            return false
        end

        Gremlin.log.trace(Evac.Id, string.format('Unit Is In Air : %s', _unit:getName()))

        return true
    end,
    heightDifference = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Calculating Unit Distance To Ground : %s', _unit))

        if type(_unit) == 'string' then
            _unit = Unit.getByName(_unit)
        end

        -- Adapted from CSAR and CTLD
        local _point = _unit:getPoint()
        return _point.y - land.getHeight({
            x = _point.x,
            y = _point.z
        })
    end,
    loadEvacuees = function(_unit, _number)
        Gremlin.log.trace(Evac.Id, string.format('Loading Evacuees Onto Unit : %s, %i', _unit, _number))

        local _zone = Evac._internal.aircraft.getZone(_unit)

        if Evac._state.extractableNow[_zone] == nil or ((Evac._state.zones.evac[_zone] == nil or Evac._state.zones.evac[_zone].active == false) and (Evac._state.zones.relay[_zone] == nil or Evac._state.zones.relay[_zone].active == false)) then
            Gremlin.log.debug(Evac.Id, string.format('Loading Evacuees : %s is not an active or registered zone\nextractable - %s\nevac zone - %s\nrelay zone - %s', _zone, mist.utils.tableShowSorted(Evac._state.extractableNow[_zone]), mist.utils.tableShowSorted(Evac._state.zones.evac[_zone]), mist.utils.tableShowSorted(Evac._state.zones.relay[_zone])))
            Gremlin.utils.displayMessageTo(_unit, 'Not in an active evac or relay zone! Try looking elsewhere.', 5)
            return
        end

        if Evac._internal.aircraft.inAir(_unit) then
            Gremlin.log.debug(Evac.Id, string.format('Loading Evacuees : %s is not on the ground', _unit))
            Gremlin.utils.displayMessageTo(_unit, 'You need to land, first! Unless you have some magic way to teleport them up? And no, these folks are in no condition for the hoist, so put that back up.', 5)
            return
        end

        _number = math.min(_number, Gremlin.utils.countTableEntries(Evac._state.extractableNow[_zone]))
        if _number < 1 then
            Gremlin.log.debug(Evac.Id, string.format('Loading Evacuees : %s is empty', _zone))
            Gremlin.utils.displayMessageTo(_unit, 'No evacuees to load here, pilot! Try looking elsewhere.', 5)
            return
        end

        local _timeout = Evac.loadUnloadPerIndividual * _number
        local _timeNow = math.floor(timer.getTime())
        mist.scheduleFunction(function(_start)
            local _left = (_start + _timeout) - timer.getTime()

            Gremlin.log.debug(Evac.Id, string.format('Loading Evacuees : %i seconds to finish', _left))

            local _displayTime = 1
            local _message

            if math.floor(_left) <= 0 then
                local _evacNameList = {}
                for _evacName, _ in pairs(Evac._state.extractableNow[_zone]) do
                    table.insert(_evacNameList, _evacName)
                end

                for _i = 1, _number do
                    local _randomIdx = math.random(#_evacNameList)
                    local _randomName = _evacNameList[_randomIdx]
                    local _evacuee = Evac._state.extractableNow[_zone][_randomName]
                    table.remove(_evacNameList, _randomIdx)
                    Evac._state.extractableNow[_zone][_randomName] = nil
                    Evac._state.extractionUnits[_unit][_randomName] = _evacuee
                end

                Evac._internal.aircraft.adaptWeight(_unit)
                _message = 'Evacuee loading complete!'
                _displayTime = 5
            else
                _message = string.format('%i seconds remaining in evacuee loading process', _left)
            end

            Gremlin.log.debug(Evac.Id, string.format('Loading Evacuees : Sending %s to %s', _message, tostring(_unit)))

            Gremlin.utils.displayMessageTo(_unit, _message, _displayTime)
        end, {_timeNow + 0.01}, _timeNow + 0.01, 1, _timeNow + _timeout + 0.02)
    end,
    countEvacuees = function(_unit)
        if type(_unit) == 'table'then
            if _unit.getName ~= nil then
                _unit = _unit:getName()
                Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees Aboard Unit : %s', _unit:getName()))
            else
                Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees Aboard Unit : %s', mist.utils.tableShowSorted(_unit)))
            end
        else
            Gremlin.log.trace(Evac.Id, string.format('Counting Evacuees Aboard Unit : %s', mist.utils.basicSerialize(_unit)))
        end

        return Gremlin.utils.countTableEntries(Evac._state.extractionUnits[_unit] or { [0] = {} }) - 1
    end,
    calculateWeight = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Calculating Weight Of Unit : %s', _unit))

        local _calculated = 0

        if Gremlin.haveCSAR then
            ---@diagnostic disable-next-line: undefined-global
            _calculated = _calculated + (csar.weight * #(csar.inTransitGroups[_unit]))
        end

        if Gremlin.haveCTLD then
            ---@diagnostic disable-next-line: undefined-global
            _calculated = _calculated + ctld.getWeightOfCargo(_unit)
        end

        local _extracted = Evac._state.extractionUnits[_unit]

        if _extracted ~= nil then
            for _i, _evacuee in pairs(_extracted) do
                if _i ~= 0 then
                    _calculated = _calculated +
                                      (_evacuee.weight or Evac._internal.utils.randomizeWeight(Evac.spawnWeight))
                end
            end
        end

        return _calculated
    end,
    adaptWeight = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Adapting Unit Weight : %s', _unit))

        local _weight = Evac._internal.aircraft.calculateWeight(_unit)
        trigger.action.setUnitInternalCargo(_unit, _weight)
    end,
    unloadEvacuees = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Unloading Evacuees From Unit : %s', _unit))

        local _zone = Evac._internal.aircraft.getZone(_unit)

        if (Evac._state.zones.safe[_zone] == nil or Evac._state.zones.safe[_zone].active == false) and (Evac._state.zones.relay[_zone] == nil or Evac._state.zones.relay[_zone].active == false) then
            Gremlin.log.debug(Evac.Id, string.format('Unloading Evacuees : %s is not an active or registered zone\nrelay zone - %s\nsafe zone - %s', _zone, mist.utils.tableShowSorted(Evac._state.zones.relay[_zone]), mist.utils.tableShowSorted(Evac._state.zones.safe[_zone])))
            Gremlin.utils.displayMessageTo(_unit, 'Not in an active relay or safe zone! Try looking elsewhere.', 5)
            return
        end

        if Evac._internal.aircraft.inAir(_unit) then
            Gremlin.log.debug(Evac.Id, string.format('Unloading Evacuees : %s is not on the ground', _unit))
            Gremlin.utils.displayMessageTo(_unit, "You need to land, first! Fastrope doesn't work with stretchers.", 5)
            return
        end

        local _number = Evac._internal.aircraft.countEvacuees(_unit)
        if _number < 1 then
            Gremlin.log.debug(Evac.Id, string.format('Unloading Evacuees : %s is empty', _unit))
            Gremlin.utils.displayMessageTo(_unit, 'No evacuees to unload?! Why are you even here, pilot?!', 5)
            return
        end

        local _timeout = Evac.loadUnloadPerIndividual * _number
        local _timeNow = math.floor(timer.getTime())
        mist.scheduleFunction(function(_start)
            local _left = (_start + _timeout) - timer.getTime()

            Gremlin.log.debug(Evac.Id, string.format('Unloading Evacuees : %f seconds to finish', _left))

            local _displayTime = 1
            local _message

            if math.floor(_left) <= 0 then
                local _groups = {}
                for _evacueeName, _evacuee in pairs(Evac._state.extractionUnits[_unit]) do
                    if _evacueeName ~= 0 then
                        Evac._state.extractableNow[_zone][_evacueeName] = _evacuee
                        _groups[Unit.getByName(_evacueeName):getGroup():getName()] = true
                    end
                end

                -- for _groupName, _ in pairs(_groups) do
                --     mist.teleportInZone(_groupName, _zone, true, 5)
                -- end

                Evac._state.extractionUnits[_unit] = {
                    [0] = Evac._state.extractionUnits[_unit][0]
                }
                Evac._internal.aircraft.adaptWeight(_unit)
                _message = 'Evacuee unloading complete!'
                _displayTime = 5
            else
                _message = string.format('%i seconds remaining in evacuee unloading process', _left)
            end

            Gremlin.log.debug(Evac.Id, string.format('Unloading Evacuees : Sending %s to %s', _message, tostring(_unit)))

            Gremlin.utils.displayMessageTo(_unit, _message, _displayTime)
        end, {_timeNow + 0.01}, _timeNow + 0.01, 1, _timeNow + _timeout + 0.02)
    end
}

-- Beacons
Evac._internal.beacons = {
    spawn = function(_zone, _side, _country, _batteryLife, _name)
        if _name == nil or _name == '' then
            _name = 'Beacon #' .. (#(Evac._state.beacons) + 1)
        end

        Gremlin.log.trace(Evac.Id, string.format('Spawning Evacuation Beacons : %s, %i, %i, %i, %s', _zone, _side, _country, _batteryLife or -2, _name))

        local _battery
        if _batteryLife == nil then
            _battery = timer.getTime() + (Evac.beaconBatteryLife * 60)
        else
            _battery = timer.getTime() + (_batteryLife * 60)
        end

        local _zonePos = mist.utils.zoneToVec3(_zone)
        local _groupId = Evac._internal.utils.getNextGroupId()
        local _unitId = Evac._internal.utils.getNextUnitId()
        local _freq = Evac._internal.beacons.getFreeADFFrequencies()
        local _freqsText = string.format('%.2f kHz - %.2f / %.2f MHz', (_freq.vhf or 30) / 1000, _freq.uhf / 1000000,
            _freq.fm / 1000000)

        local _radioGroup = {
            ['visible'] = false,
            ['hidden'] = false,
            ['units'] = {{
                ['y'] = _zonePos.z,
                ['type'] = 'TACAN_beacon',
                ['name'] = 'VHF Unit #' .. _unitId .. ' - ' .. _name .. ' [' .. _freqsText .. ']',
                ['heading'] = 0,
                ['playerCanDrive'] = true,
                ['skill'] = 'Excellent',
                ['x'] = _zonePos.x
            }, {
                ['y'] = _zonePos.z,
                ['type'] = 'TACAN_beacon',
                ['name'] = 'UHF Unit #' .. (_unitId + 1) .. ' - ' .. _name .. ' [' .. _freqsText .. ']',
                ['heading'] = 0,
                ['playerCanDrive'] = true,
                ['skill'] = 'Excellent',
                ['x'] = _zonePos.x
            }, {
                ['y'] = _zonePos.z,
                ['type'] = 'TACAN_beacon',
                ['name'] = 'FM Unit #' .. (_unitId + 2) .. ' - ' .. _name .. ' [' .. _freqsText .. ']',
                ['heading'] = 0,
                ['playerCanDrive'] = true,
                ['skill'] = 'Excellent',
                ['x'] = _zonePos.x
            }},
            ['name'] = 'Group #' .. _groupId .. ' - ' .. _name,
            ['task'] = {},
            ['category'] = Group.Category.GROUND,
            ['country'] = _country
        }

        mist.dynAdd(_radioGroup)

        local _beaconDetails = {
            vhf = _freq.vhf,
            uhf = _freq.uhf,
            fm = _freq.fm,
            group = _radioGroup.name,
            text = _freqsText,
            battery = _battery,
            side = _side
        }

        Evac._internal.beacons.update(_beaconDetails)
        table.insert(Evac._state.beacons, _beaconDetails)

        return _beaconDetails
    end,
    getFreeADFFrequencies = function()
        Gremlin.log.trace(Evac.Id, string.format('Looking Up Free ADF Frequencies'))

        if #Evac._state.frequencies.uhf.free <= 0 then
            Evac._state.frequencies.uhf.free = Evac._state.frequencies.uhf.used
            Evac._state.frequencies.uhf.used = {}
        end

        local _uhf = table.remove(Evac._state.frequencies.uhf.free, math.random(1, #Evac._state.frequencies.uhf.free))
        table.insert(Evac._state.frequencies.uhf.used, _uhf)

        if #Evac._state.frequencies.vhf.free <= 0 then
            Evac._state.frequencies.vhf.free = Evac._state.frequencies.vhf.used
            Evac._state.frequencies.vhf.used = {}
        end

        local _vhf = table.remove(Evac._state.frequencies.vhf.free, math.random(1, #Evac._state.frequencies.vhf.free))
        table.insert(Evac._state.frequencies.vhf.used, _vhf)

        if #Evac._state.frequencies.fm.free <= 0 then
            Evac._state.frequencies.fm.free = Evac._state.frequencies.fm.used
            Evac._state.frequencies.fm.used = {}
        end

        local _fm = table.remove(Evac._state.frequencies.fm.free, math.random(1, #Evac._state.frequencies.fm.free))
        table.insert(Evac._state.frequencies.fm.used, _fm)

        return {
            uhf = _uhf,
            vhf = _vhf,
            fm = _fm
        }
    end,
    list = function(_unit)
        Gremlin.log.trace(Evac.Id, string.format('Listing Beacons For Unit : %s', tostring(_unit)))

        if _unit ~= nil then
            local _unitObj
            if type(_unit) == 'string' then
                _unitObj = Unit.getByName(_unit)
            else
                _unitObj = _unit
            end

            if _unitObj ~= nil then
                local _message
                for _x, _details in pairs(Evac._state.beacons) do
                    if _details.side == (Group.getCoalition(Unit.getGroup(_unitObj)) or 0) then
                        _message = string.format('%s%s (%s)\n', _message or '', _details.group, _details.text or '')
                    end
                end

                Gremlin.log.debug(Evac.Id, string.format('Got Beacon List For Unit : %s, %s', tostring(_unit), _message or 'none'))

                if _message ~= nil and _message ~= '' then
                    Gremlin.utils.displayMessageTo(_unitObj:getGroup(), 'Evacuation Beacons:\n' .. _message, 15)
                else
                    Gremlin.utils.displayMessageTo(_unitObj:getGroup(), 'No Active Evacuation Beacons', 15)
                end
            end
        end
    end,
    update = function(_beaconDetails)
        Gremlin.log.trace(Evac.Id, string.format('Updating Beacon Lifecycles : %s', mist.utils.tableShowSorted(_beaconDetails)))

        local _radioGroup = Group.getByName(_beaconDetails.group)
        if _radioGroup == nil then
            return false
        end

        local _batteryLife = _beaconDetails.battery - timer.getTime()
        if _batteryLife < 1 and _beaconDetails.battery ~= -1 then
            trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | VHF')
            trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | UHF')
            trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | FM')
            _radioGroup:destroy()

            return false
        end

        local _controller = _radioGroup:getController()
        local _sound = 'l10n/DEFAULT/' .. Evac.beaconSound

        _controller:setOption(AI.Option.Ground.id.ROE, AI.Option.Ground.val.ROE.WEAPON_HOLD)

        trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | VHF')
        trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | UHF')
        trigger.action.stopRadioTransmission(_beaconDetails.text .. ' | FM')
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(1):getPoint(), 0, true, _beaconDetails.vhf, 1000, _beaconDetails.text .. ' | VHF')
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(2):getPoint(), 0, true, _beaconDetails.uhf, 1000, _beaconDetails.text .. ' | UHF')
        trigger.action.radioTransmission(_sound, _radioGroup:getUnit(3):getPoint(), 1, true, _beaconDetails.fm, 1000, _beaconDetails.text .. ' | FM')

        return true
    end,
    killDead = function()
        Gremlin.log.trace(Evac.Id, string.format('Destroying Dead Beacons'))

        timer.scheduleFunction(Evac._internal.beacons.killDead, nil, timer.getTime() + 60)

        for _index, _beaconDetails in ipairs(Evac._state.beacons) do
            if _beaconDetails.battery - timer.getTime() <= 0 and _beaconDetails.battery ~= -1 then
                for _i, _freq in ipairs(Evac._state.frequencies.uhf.used) do
                    if _freq == _beaconDetails.uhf then
                        table.insert(Evac._state.frequencies.uhf.free, _freq)
                        table.remove(Evac._state.frequencies.uhf.used, _i)
                    end
                end

                for _i, _freq in ipairs(Evac._state.frequencies.vhf.used) do
                    if _freq == _beaconDetails.vhf then
                        table.insert(Evac._state.frequencies.vhf.free, _freq)
                        table.remove(Evac._state.frequencies.vhf.used, _i)
                    end
                end

                for _i, _freq in ipairs(Evac._state.frequencies.fm.used) do
                    if _freq == _beaconDetails.fm then
                        table.insert(Evac._state.frequencies.fm.free, _freq)
                        table.remove(Evac._state.frequencies.fm.used, _i)
                    end
                end

                table.remove(Evac._state.beacons, _index)
            end
        end
    end,
    generateVHFrequencies = function()
        Gremlin.log.trace(Evac.Id, string.format('Calculating VHF Frequencies'))

        local _skipFrequencies = {745, -- Astrahan
        381, 384, 300.50, 312.5, 1175, 342, 735, 300.50, 353.00, 440, 795, 525, 520, 690, 625, 291.5, 300.50, 435,
                                  309.50, 920, 1065, 274, 312.50, 580, 602, 297.50, 750, 485, 950, 214, 1025, 730, 995,
                                  455, 307, 670, 329, 395, 770, 380, 705, 300.5, 507, 740, 1030, 515, 330, 309.5, 348,
                                  462, 905, 352, 1210, 942, 435, 324, 320, 420, 311, 389, 396, 862, 680, 297.5, 920,
                                  662, 866, 907, 309.5, 822, 515, 470, 342, 1182, 309.5, 720, 528, 337, 312.5, 830, 740,
                                  309.5, 641, 312, 722, 682, 1050, 1116, 935, 1000, 430, 577, 326 -- Nevada
        }

        Evac._state.frequencies.vhf.free = {}
        local _start = 200000

        while _start < 400000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 10000
        end

        _start = 400000
        while _start < 850000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 10000
        end

        _start = 850000
        while _start <= 1250000 do
            local _found = false
            for _, value in pairs(_skipFrequencies) do
                if value * 1000 == _start then
                    _found = true
                    break
                end
            end

            if _found == false then
                table.insert(Evac._state.frequencies.vhf.free, _start)
            end

            _start = _start + 50000
        end
    end,
    generateUHFrequencies = function()
        Gremlin.log.trace(Evac.Id, string.format('Calculating UHF Frequencies'))

        Evac._state.frequencies.uhf.free = {}
        local _start = 220000000

        while _start < 399000000 do
            table.insert(Evac._state.frequencies.uhf.free, _start)
            _start = _start + 500000
        end
    end,
    generateFMFrequencies = function()
        Gremlin.log.trace(Evac.Id, string.format('Calculating FM Frequencies'))

        Evac._state.frequencies.fm.free = {}
        local _start = 220000000

        while _start < 399000000 do
            _start = _start + 500000
        end

        for _first = 3, 7 do
            for _second = 0, 5 do
                for _third = 0, 9 do
                    for _fourth = 0, 1 do
                        local _frequency = ((1000 * _first) + (100 * _second) + (10 * _third) + (5 * _fourth)) * 10000
                        table.insert(Evac._state.frequencies.fm.free, _frequency)
                    end
                end
            end
        end
    end
}

-- Smoke
Evac._internal.smoke = {
    refresh = function()
        Gremlin.log.trace(Evac.Id, string.format('Refreshing Smoke'))

        for _, _zoneData in pairs(Gremlin.utils.mergeTables(Evac._state.zones.evac, Evac._state.zones.relay,
            Evac._state.zones.safe)) do
            local _zone = trigger.misc.getZone(_zoneData.name)
            if _zone ~= nil and _zoneData.active then
                local _pos2 = {
                    x = _zone.point.x,
                    y = _zone.point.z
                }
                local _alt = land.getHeight(_pos2)
                local _pos3 = {
                    x = _pos2.x,
                    y = _alt,
                    z = _pos2.y
                }

                trigger.action.smoke(_pos3, _zoneData.smoke)
            end
        end

        timer.scheduleFunction(Evac._internal.smoke.refresh, nil, timer.getTime() + 300)
    end
}

-- Zones
Evac._internal.zones = {
    register = function(_zone, _smoke, _side, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Registering Zone Internally : %s, %i, %i, %i', _zone, _smoke, _side,
            _evacMode))

        Evac._state.zones[Evac.modeToText[_evacMode]][_zone] = {
            active = false,
            name = _zone,
            side = _side,
            smoke = _smoke,
            mode = _evacMode
        }
        Evac._state.extractableNow[_zone] = {}
    end,
    generateEvacuees = function(_side, _numberOrComposition, _country)
        if type(_numberOrComposition) == 'table' then
            Gremlin.log.trace(Evac.Id, string.format('Generating Evacuees : %i, %s, %i', _side,
                mist.utils.tableShowSorted(_numberOrComposition), _country))
        else
            Gremlin.log.trace(Evac.Id,
                string.format('Generating Evacuees : %i, %i, %i', _side, _numberOrComposition, _country))
        end

        local _groupName = 'Evacuee Group'
        local _unitType = 'Ejected Pilot'
        local _groupId = Evac._internal.utils.getNextGroupId()
        local _composition = {}
        local _troops = {}
        local _weight = 0

        if type(_numberOrComposition) == 'number' then
            for _i = 1, _numberOrComposition do
                _composition[_i] = {
                    type = _unitType
                }
            end
        else
            _composition = _numberOrComposition or {}
        end

        for _i, _unit in ipairs(_composition) do
            if _unit.type == nil then
                _unit.type = _unitType
            end
            if _unit.unitId == nil then
                _unit.unitId = Evac._internal.utils.getNextUnitId() + (_i - 1)
            end
            if _unit.unitName == nil then
                _unit.unitName = string.format('Evacuee: %s #%i', _unit.type, _unit.unitId)
            end
            if _unit.weight == nil then
                _unit.weight = Evac._internal.utils.randomizeWeight(Evac.spawnWeight)
            end

            _troops[_i] = _unit
            _weight = _weight + _unit.weight
        end

        return {
            units = _troops,
            groupId = _groupId,
            groupName = string.format('%s %i', _groupName, _groupId),
            side = _side,
            country = _country,
            weight = _weight
        }
    end,
    activate = function(_zone, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Activating Zone Internally : %s, %i', _zone, _evacMode))

        if
            Evac.modeToText[_evacMode] ~= nil and
            Evac._state.zones[Evac.modeToText[_evacMode]] ~= nil and
            Evac._state.zones[Evac.modeToText[_evacMode]][_zone] ~= nil
        then
            Evac._state.zones[Evac.modeToText[_evacMode]][_zone].active = true
        end
    end,
    setRemaining = function(_zone, _side, _country, _numberOrComposition)
        if type(_numberOrComposition) == 'table' then
            Gremlin.log.trace(Evac.Id,
                string.format('Setting Remaning Evacuees Internally : %s, %i, %i, %s', _zone, _side, _country,
                    mist.utils.tableShowSorted(_numberOrComposition)))
        else
            Gremlin.log.trace(Evac.Id, string.format('Setting Remaning Evacuees Internally : %s, %i, %i, %i', _zone,
                _side, _country, _numberOrComposition))
        end

        for _unitName, _unit in pairs(Evac._state.extractableNow[_zone]) do
            if not Evac._internal.aircraft.inZone(_unitName, _zone) then
                local _newZone = Evac._internal.aircraft.getZone(_unitName)

                if _newZone ~= nil and Evac._state.extractableNow[_newZone] ~= nil then
                    Evac._state.extractableNow[_newZone][_unitName] = _unit
                end
            else
                Unit.getByName(_unitName):destroy()
            end

            Evac._state.extractableNow[_zone][_unitName] = nil
        end

        Evac.groups.spawn(_side, _numberOrComposition, _country, _zone, 5)
    end,
    count = function(_zone, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Counting Units In Zone Internally : %s, %i', _zone, _evacMode))

        local _count = 0

        if Evac._state.zones[Evac.modeToText[_evacMode]][_zone] ~= nil then
            -- Can't use # here, since the keys on this table are not integers, so we count instead
            for _, _ in pairs(Evac._state.extractableNow[_zone]) do
                _count = _count + 1
            end
        end

        return _count
    end,
    isIn = function(_unit, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Checking Whether Unit Is In Zones Internally : %s, %s', _unit,
            tostring(_evacMode)))

        local _unitObj = Unit.getByName(_unit)

        if _unitObj ~= nil then
            if type(_evacMode) == 'string' then
                local _zone = _evacMode
                local _zoneData = Evac._state.zones.evac[_zone] or Evac._state.zones.relay[_zone] or
                                      Evac._state.zones.safe[_zone] or {
                    active = false
                }
                local _unitPoint = _unitObj:getPoint()

                return _zoneData.active and mist.pointInZone(_unitPoint, _zone)
            else
                for _, _zoneData in pairs(Evac._state.zones[Evac.modeToText[_evacMode]]) do
                    if _zoneData.active and mist.pointInZone(_unitObj:getPoint(), _zoneData.name) then
                        return true
                    end
                end
            end
        end

        return false
    end,
    deactivate = function(_zone, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Deactivating Zone Internally : %s, %i', _zone, _evacMode))

        Evac._state.zones[Evac.modeToText[_evacMode]][_zone].active = false
    end,
    unregister = function(_zone, _evacMode)
        Gremlin.log.trace(Evac.Id, string.format('Unregistering Zone Internally : %s, %i', _zone, _evacMode))

        for _unit, _ in pairs(Evac._state.extractableNow[_zone]) do
            local _unitObj = Unit.getByName(_unit)
            if _unitObj ~= nil then
                _unitObj:destroy()
            end
        end

        Evac._state.extractableNow[_zone] = nil
        Evac._state.zones[Evac.modeToText[_evacMode]][_zone] = nil
    end
}

-- Menu
Evac._internal.menu = {
    addToF10 = function()
        Gremlin.log.trace(Evac.Id, string.format('Updating F10 Menu For %i Units', Gremlin.utils.countTableEntries(Evac._state.extractionUnits)))

        timer.scheduleFunction(Evac._internal.menu.addToF10, nil, timer.getTime() + 10)

        for _unitName, _extractorList in pairs(Evac._state.extractionUnits) do
            local _unit = _extractorList[0] or Unit.getByName(_unitName)
            if _unit ~= nil and _unit:isExist() then
                if _extractorList[0] == nil then
                    Evac._state.extractionUnits[_unitName][0] = _unit
                end

                local _groupId = _unit:getGroup():getID()
                local _groupName = _unit:getGroup():getName()

                local _rootPath
                if Evac._state.menuAdded[_groupId] == nil then
                    _rootPath = missionCommands.addSubMenuForGroup(_groupId, 'Gremlin Evac')
                    Evac._state.menuAdded[_groupId] = { root = _rootPath }
                    Gremlin.log.trace(Evac.Id, string.format('Added Root Menu'))
                else
                    _rootPath = Evac._state.menuAdded[_groupId].root
                end

                for _cmdIdx, _command in pairs(Evac._internal.menu.commands) do
                    local _when = false
                    if type(_command.when) == 'boolean' then
                        _when = _command.when
                    elseif type(_command.when) == 'table' then
                        ---@diagnostic disable-next-line: undefined-field
                        local _whenArgs = Gremlin.utils.parseFuncArgs(_command.when.args, {
                            unit = _unit,
                            group = _unit:getGroup()
                        })

                        ---@diagnostic disable-next-line: undefined-field
                        if _command.when.func(table.unpack(_whenArgs)) == _command.when.value and _command.when.comp == 'equal' then
                            _when = true
                        ---@diagnostic disable-next-line: undefined-field
                        elseif _command.when.func(table.unpack(_whenArgs)) ~= _command.when.value and _command.when.comp == 'inequal' then
                            _when = true
                        end
                    end

                    if Evac._state.menuAdded[_groupId][_cmdIdx] ~= nil then
                        missionCommands.removeItemForGroup(_groupId, Evac._state.menuAdded[_groupId][_cmdIdx])
                    end

                    local _args = Gremlin.utils.parseFuncArgs(_command.args, {
                        unit = _unit,
                        group = _unit:getGroup()
                    })
                    if _when then
                        if type(_command.text) == "string" then
                            Evac._state.menuAdded[_groupId][_cmdIdx] = missionCommands.addCommandForGroup(_groupId, _command.text, _rootPath, function(_args) _command.func(table.unpack(_args)) end, _args)
                            Gremlin.log.trace(Evac.Id, string.format('Added Menu Item To Group %s (%s) : "%s"', _groupName, _unitName, _command.text))
                        else
                            Evac._state.menuAdded[_groupId][_cmdIdx] = missionCommands.addCommandForGroup(_groupId, _command.text(table.unpack(_args)), _rootPath, function(_args) _command.func(table.unpack(_args)) end, _args)
                            Gremlin.log.trace(Evac.Id, string.format('Added Menu Item To Group %s (%s) : "%s"', _groupName, _unitName, _command.text(table.unpack(_args))))
                        end
                    end
                end
            end
        end
    end,
    commands = {{
        text = 'Scan For Evacuation Beacons',
        func = Evac.units.findEvacuees,
        args = {'{unit}:name'},
        when = true
    }, {
        text = function(_unit)
            local _unitObj = Unit.getByName(_unit)
            if _unitObj ~= nil then
                local _zone = Evac._internal.aircraft.getZone(_unit)
                return string.format('Load %i Evacuees', math.min((Evac.carryLimits[_unitObj:getTypeName()] or 0), Gremlin.utils.countTableEntries(Evac._state.extractableNow[_zone])))
            end
        end,
        func = Evac.units.loadEvacuees,
        args = {'{unit}:name'},
        when = {
            func = function(_unit)
                if not Evac._internal.aircraft.inAir(_unit) and (Evac.zones.evac.isIn(_unit) or Evac.zones.relay.isIn(_unit)) then
                    local _unitObj = Unit.getByName(_unit)
                    if _unitObj ~= nil then
                        local _zone = Evac._internal.aircraft.getZone(_unit)
                        local _seats = math.min((Evac.carryLimits[_unitObj:getTypeName()] or 0), Gremlin.utils.countTableEntries(Evac._state.extractableNow[_zone]))
                        return _seats > Evac._internal.aircraft.countEvacuees(_unit)
                    end
                end

                return false
            end,
            args = {'{unit}:name'},
            comp = 'equal',
            value = true
        }
    }, {
        text = function(_unit)
            return string.format('Unload %i Evacuees', Evac._internal.aircraft.countEvacuees(_unit))
        end,
        func = Evac.units.unloadEvacuees,
        args = {'{unit}:name'},
        when = {
            func = function(_unit)
                if not Evac._internal.aircraft.inAir(_unit) and (Evac.zones.safe.isIn(_unit) or Evac.zones.relay.isIn(_unit)) then
                    return Evac._internal.aircraft.countEvacuees(_unit)
                end

                return 0
            end,
            args = {'{unit}:name'},
            comp = 'inequal',
            value = 0
        }
    }}
}

-- Utilities
Evac._internal.utils = {
    currentGroup = Evac.idStart + 0,
    currentUnit = Evac.idStart + 0,
    endIfLossesTooHigh = function()
        Gremlin.log.trace(Evac.Id, string.format('Checking Whether To End The Mission'))

        for _side, _maxExtract in pairs(Evac.maxExtractable) do
            local _lost = Evac._state.lostEvacuees[_side]

            local _generic = _lost['Ejected Pilot'] / _maxExtract['Ejected Pilot']
            local _infantry = _lost.Infantry / _maxExtract.Infantry
            local _2b11 = _lost['2B11'] / _maxExtract['2B11']
            local _m249 = _lost.M249 / _maxExtract.M249
            local _rpg = _lost.RPG / _maxExtract.RPG
            local _stingerIgla = _lost.StingerIgla / _maxExtract.StingerIgla
            local _jtac = _lost.JTAC / _maxExtract.JTAC
            local _combined = (_generic + _infantry + _2b11 + _m249 + _rpg + _stingerIgla + _jtac) / 7

            if (_combined > 0 and _combined >= (Evac.lossThresholds[_side] / 100)) or
                (_generic > 0 and _generic >= (Evac.lossThresholds[_side] / 100)) then
                trigger.action.setUserFlag(Evac.lossFlags[_side], true)
            end
        end
    end,
    getNextGroupId = function()
        Gremlin.log.trace(Evac.Id, string.format('Getting Next Group ID'))

        if Gremlin.haveCTLD then
            ---@diagnostic disable-next-line: undefined-global
            Evac._internal.utils.currentGroup = ctld.getNextGroupId() + Evac.idStart
        else
            Evac._internal.utils.currentGroup = mist.getNextGroupId() + Evac.idStart
        end

        return Evac._internal.utils.currentGroup
    end,
    getNextUnitId = function()
        Gremlin.log.trace(Evac.Id, string.format('Getting Next Unit ID'))

        if Gremlin.haveCTLD then
            ---@diagnostic disable-next-line: undefined-global
            Evac._internal.utils.currentUnit = ctld.getNextUnitId() + Evac.idStart
        else
            Evac._internal.utils.currentUnit = mist.getNextUnitId() + Evac.idStart
        end

        return Evac._internal.utils.currentUnit
    end,
    randomizeWeight = function(_weight)
        Gremlin.log.trace(Evac.Id, string.format('Randomizing Weight : %i', _weight or -1))

        return (math.random(90, 120) * (_weight or Evac.spawnWeight)) / 100
    end,
    unitDataToList = function(_units, _point, _scatterRadius)
        Gremlin.log.trace(Evac.Id, string.format('Converting Evac Unit Descriptions To DCS Internal Specs'))

        local _unitsOut = {}
        ---@diagnostic disable-next-line: deprecated
        local _angle = math.atan2(_point.z, _point.x)
        local _xOffset = math.cos(_angle) * math.random(_scatterRadius)
        local _yOffset = math.sin(_angle) * math.random(_scatterRadius)

        for _i, _unit in pairs(_units) do
            _unitsOut[_i] = {
                type = _unit.type,
                unitId = _unit.unitId,
                name = _unit.unitName,
                skill = 'Excellent',
                playerCanDrive = false,
                x = _point.x + _xOffset,
                y = _point.z + _yOffset,
                heading = _angle
            }
        end

        return _unitsOut
    end
}

-- Auto-spawn
Evac._internal.doSpawns = function()
    Gremlin.log.trace(Evac.Id, string.format('Auto-Spawning Units (As Needed)'))

    local _remaining = function(_side)
        Gremlin.log.debug(Evac.Id, string.format('Checking Whether We Can Spawn More Evacuees : %s side has %s out of %s already spawned', Gremlin.SideToText[_side], mist.utils.tableShowSorted(Evac._state.spawns.alreadySpawned[_side]), mist.utils.tableShowSorted(Evac.maxExtractable[_side])))

        local _haveLeft = {}

        _haveLeft['Ejected Pilot'] = Evac.maxExtractable[_side]['Ejected Pilot'] - Evac._state.spawns.alreadySpawned[_side]['Ejected Pilot']
        _haveLeft['Infantry'] = Evac.maxExtractable[_side].Infantry - Evac._state.spawns.alreadySpawned[_side].Infantry
        _haveLeft['M249'] = Evac.maxExtractable[_side].M249 - Evac._state.spawns.alreadySpawned[_side].M249
        _haveLeft['RPG'] = Evac.maxExtractable[_side].RPG - Evac._state.spawns.alreadySpawned[_side].RPG
        _haveLeft['StingerIgla'] = Evac.maxExtractable[_side].StingerIgla - Evac._state.spawns.alreadySpawned[_side].StingerIgla
        _haveLeft['2B11'] = Evac.maxExtractable[_side]['2B11'] - Evac._state.spawns.alreadySpawned[_side]['2B11']
        _haveLeft['JTAC'] = Evac.maxExtractable[_side].JTAC - Evac._state.spawns.alreadySpawned[_side].JTAC

        Gremlin.log.debug(Evac.Id, string.format('Checked Whether We Can Spawn More Evacuees : remaining spawns are %s', mist.utils.tableShowSorted(_haveLeft)))

        return _haveLeft
    end

    local _doLoop = function(_zone, _rates, _lastChecked)
        Gremlin.log.debug(Evac.Id, string.format('Auto-Spawning In Zone : %s, %s, %s', _zone, mist.utils.tableShowSorted(_rates), tostring(_lastChecked)))

        local _addedUnits = false

        for _side, _rateSource in pairs(_rates) do
            local _rate = mist.utils.deepCopy(_rateSource)
            local _spawnLimits = _remaining(_side)

            if _lastChecked ~= nil and _lastChecked + (math.abs(_rate.per) * _rate.period) <= timer.getTime() then
                -- Figure out what to spawn and where
                local _units
                if _rate.units == 0 then
                    _units = {}
                    for i = 1, Evac.maxExtractable[_side]['Ejected Pilot'] do
                        table.insert(_units, {
                            type = 'Ejected Pilot'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side].Infantry do
                        table.insert(_units, {
                            type = 'Infantry'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side].StingerIgla do
                        table.insert(_units, {
                            type = 'StingerIgla'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side].RPG do
                        table.insert(_units, {
                            type = 'RPG'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side].M249 do
                        table.insert(_units, {
                            type = 'M249'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side]['2B11'] do
                        table.insert(_units, {
                            type = '2B11'
                        })
                    end
                    for i = 1, Evac.maxExtractable[_side].JTAC do
                        table.insert(_units, {
                            type = 'JTAC'
                        })
                    end
                else
                    _units = _rate.units
                end

                if type(_units) == 'number' then
                    _units = math.min(_units, _spawnLimits['Ejected Pilot'])
                else
                    local _have = { ['Ejected Pilot'] = 0, Infantry = 0, M249 = 0, RPG = 0, StingerIgla = 0, ['2B11'] = 0, JTAC = 0 }

                    for _idx, _unit in pairs(_units) do
                        _have[_unit.type] = _have[_unit.type] + 1

                        if _spawnLimits[_unit.type] < _have[_unit.type] then

                            -- Change the type to ['Ejected Pilot'], if possible, or remove it entirely otherwise
                            -- Tries to spawn the right number of units even if it can't spawn the exact types
                            if _unit.type ~= 'Ejected Pilot' and _spawnLimits['Ejected Pilot'] >= _have['Ejected Pilot'] then
                                _units[_idx] = Gremlin.utils.mergeTables(_unit, { type = 'Ejected Pilot' })
                            else
                                _units[_idx] = nil
                            end
                        end
                    end
                end

                -- Actually Spawn Units
                if type(_units) == 'number' and _units < 0 then
                    local _spawned = #(Evac._state.extractableNow[_zone] or {})
                    local _removed = 0

                    for _idx, _unit in pairs(Evac._state.extractableNow[_zone]) do
                        if _removed >= math.abs(_units) or _removed >= _spawned then
                            break
                        end

                        local _unitObj = Unit.getByName(_unit.unitName)
                        if _unitObj ~= nil then
                            _unitObj:destroy()
                        end

                        Evac._state.extractableNow[_zone][_idx] = nil
                        _removed = _removed + 1
                        _addedUnits = true
                    end

                    Gremlin.log.debug(Evac.Id, string.format('Removed %i evacuees from %s', _removed, _zone))
                else
                    Evac.groups.spawn(_side, _units, _side, _zone, 5)
                    _addedUnits = true

                    if type(_units) == 'table' then
                        Gremlin.log.debug(Evac.Id, string.format('Spawned %i evacuees in %s', #_units, _zone))
                    else
                        Gremlin.log.debug(Evac.Id, string.format('Spawned %i evacuees in %s', _units, _zone))
                    end
                end

                -- Maintain internal data structures
                if Evac._state.spawns.alreadySpawned[_side] == nil then
                    Evac._state.spawns.alreadySpawned[_side] = {
                        ['Ejected Pilot'] = 0,
                        Infantry = 0,
                        M249 = 0,
                        RPG = 0,
                        StingerIgla = 0,
                        ['2B11'] = 0,
                        JTAC = 0
                    }
                end

                if type(_units) == 'number' then
                    Evac._state.spawns.alreadySpawned[_side]['Ejected Pilot'] = Evac._state.spawns.alreadySpawned[_side]['Ejected Pilot'] + _units
                elseif type(_units) == 'table' then
                    for _, _unit in pairs(_units) do
                        local _spawnType = _unit.type

                        Evac._state.spawns.alreadySpawned[_side][_spawnType] = Evac._state.spawns.alreadySpawned[_side][_spawnType] + 1
                    end
                end

                Gremlin.log.debug(Evac.Id, string.format('Evacuee Count Updated : now at %s out of %s', mist.utils.tableShowSorted(Evac._state.spawns.alreadySpawned[_side]), mist.utils.tableShowSorted(Evac.maxExtractable[_side])))
            end
        end

        return _addedUnits
    end

    timer.scheduleFunction(Evac._internal.doSpawns, nil, timer.getTime() + 10)

    for _zone, _rates in pairs(Evac.spawnRates) do
        local _lastChecked = Evac._state.spawns.lastChecked[_zone] or 0
        local _addedUnits = false

        if _zone == '_global' then
            ---@diagnostic disable-next-line: redefined-local
            for _zone, _zoneData in pairs(Evac._state.zones.evac) do
                if _zoneData.active then
                    _addedUnits = _addedUnits or _doLoop(_zone, _rates, _lastChecked)
                end
            end
        else
            local _zoneData = Evac._state.zones.evac[_zone]
            if _zoneData.active then
                _addedUnits = _doLoop(_zone, _rates, _lastChecked)
            end
        end

        if _addedUnits then
            for _side, _rate in pairs(_rates) do
                if _rate.per <= 0 then
                    Evac.spawnRates[_zone][_side] = nil
                end
            end

            Evac._state.spawns.lastChecked[_zone] = timer.getTime()
        end
    end

    Evac._state.spawns.lastChecked[0] = timer.getTime()

    Gremlin.log.debug(Evac.Id, string.format('Finished Auto-Spawning Units (As Needed)'))
end

-- Event handlers
Evac._internal.handlers = {
    fullLoss = {
        event = world.event.S_EVENT_UNIT_LOST,
        fn = function(_event)
            Gremlin.log.trace(Evac.Id, string.format('Handling Loss Event'))

            local _unit = _event.initiator

            if _unit ~= nil then
                local _name = _unit:getName()

                if Evac._state.extractionUnits[_name] ~= nil and Gremlin.utils.countTableEntries(Evac._state.extractionUnits[_name]) > 0 then
                    local _side

                    if Evac._state.extractionUnits[_name][0] ~= nil then
                        _side = Group.getCoalition(Unit.getGroup(Evac._state.extractionUnits[_name][0]))
                    else
                        _side = 0
                    end

                    for _i, _evacuee in pairs(Evac._state.extractionUnits[_name]) do
                        if _i ~= 0 then
                            local _type = _evacuee.type

                            if _type == nil then
                                _type = 'Ejected Pilot'
                            end

                            if Evac._state.lostEvacuees[_side] == nil then
                                Evac._state.lostEvacuees[_side] = {
                                    ['Ejected Pilot'] = 0,
                                    Infantry = 0,
                                    M249 = 0,
                                    RPG = 0,
                                    StingerIgla = 0,
                                    ['2B11'] = 0,
                                    JTAC = 0,
                                }
                            end

                            Evac._state.lostEvacuees[_side][_type] = (Evac._state.lostEvacuees[_side][_type] or 0) + 1
                        end
                    end

                    Gremlin.log.debug(Evac.Id, string.format('Lost Evacuees! : %s', mist.utils.tableShowSorted(Evac._state.extractionUnits[_name])))

                    Gremlin.utils.displayMessageTo(Gremlin.SideToText[_side], string.format('We just lost %i evacuees! Step it up, pilots!', Gremlin.utils.countTableEntries(Evac._state.extractionUnits[_name])), 15)

                    Evac._state.extractionUnits[_name] = {
                        [0] = Evac._state.extractionUnits[_name][0],
                    }
                    Evac._internal.utils.endIfLossesTooHigh()
                else
                    Gremlin.log.debug(Evac.Id, string.format('No evacuees were harmed in the making of this explosion : Unit %s Lost', _name))
                end
            end
        end
    },
}

--[[
Setup Gremlin Evac! The argument should contain a configuration table as
shown below.

Example providing all the defaults:

```
Evac:setup({
    beaconBatteryLife = 30,
    beaconSound = 'beacon.ogg',
    carryLimits = {
        ['C-130'] = 90,
        ['CH-43E'] = 55,
        ['CH-47D'] = 44,
        ['Mi-8MT'] = 24,
        ['Mi-24P'] = 5,
        ['Mi-24V'] = 5,
        ['Mi-26'] = 70,
        ['SH60B'] = 5,
        ['UH-1H'] = 8,
        ['UH-60L'] = 11,
    },
    idStart = 500,
    loadUnloadPerIndividual = 30,
    lossFlags = { 'GremlinEvacRedLoss', 'GremlinEvacBlueLoss' }
    lossThresholds = { 25, 25 },
    maxExtractable = {
        {
            ['Ejected Pilot'] = 0,
            Infantry = 0,
            M249 = 0,
            RPG = 0,
            StingerIgla = 0,
            ['2B11'] = 0,
            JTAC = 0,
            Downed = 0,
        },
        {
            ['Ejected Pilot'] = 0,
            Infantry = 0,
            M249 = 0,
            RPG = 0,
            StingerIgla = 0,
            ['2B11'] = 0,
            JTAC = 0,
            Downed = 0,
        },
    },
    spawnRates = {
        _global = {
            {
                units = 0, -- 0 loads all; + adds, - subtracts
                per = 0,   -- 0 means only at launch; + every, - once after
                period = Gremlin.Periods.Second,
            },
            {
                units = 0, -- 0 loads all; + adds, - subtracts
                per = 0,   -- 0 means only at launch; + every, - once after
                period = Gremlin.Periods.Second,
            },
        },
    },
    spawnWeight = 100,
    startingZones = {},
})
```

`spawnRates` is a table whose keys are zone names, with one special zone
called `_global` that applies to the entire map. Each value is a table of sides
(the standard red = 1, blue = 2 approach), whose values are tables listing
the number or composition of units to generate, and how long to wait between
spawns. In English, it would probably be described as '{units} unit(s) every
{per} {period}(s)'. The special value 0 for `units` means 'as many as allowed';
negative values actually remove evacuees according to the same rules. `period`
should be a constant from `Gremlin.Periods`. `per` indicates how many periods
to wait between auto spawns; the special value 0 means 'mission start', while
positive values run every `per` `period`s, and negative means only spawn once
rather than repeatedly.

`startingZones` is also keyed by zone name, but the contents describe the
zone(s) themselves. Four keys are required: `mode` (one of the constants in
`Evac.modes`), `name`, `smoke` (one of the constants in
`trigger.smokeColor`), and `side` (the coalition number this zone should be
attached to).
]]
function Evac:setup(config)
    assert(Gremlin ~= nil,
        '\n\n** HEY MISSION-DESIGNER! **\n\nGremlin Script Tools has not been loaded!\n\nMake sure Gremlin Script Tools is loaded *before* running this script!\n')

    if not Gremlin.alreadyInitialized or config.forceReload then
        Gremlin:setup(config)
    end

    if Evac._state.alreadyInitialized and not config.forceReload then
        Gremlin.log.info(Evac.Id,
            string.format('Bypassing initialization because Evac._state.alreadyInitialized = true'))
        return
    end

    Gremlin.log.info(Evac.Id, string.format('Starting setup of %s version %s!', Evac.Id, Evac.Version))

    -- start configuration
    if not Evac._state.alreadyInitialized or (config ~= nil and config.forceReload) then
        if config == nil then
            config = {}
        end

        Evac.beaconBatteryLife = config.beaconBatteryLife or 30
        Evac.beaconSound = config.beaconSound or 'beacon.ogg'
        Evac.carryLimits = config.carryLimits or {
            ['C-130'] = 90,
            ['CH-43E'] = 55,
            ['CH-47D'] = 44,
            ['Hercules'] = 90,
            ['Mi-8MT'] = 24,
            ['Mi-24P'] = 5,
            ['Mi-24V'] = 5,
            ['Mi-26'] = 70,
            ['SH60B'] = 5,
            ['UH-1H'] = 8,
            ['UH-60L'] = 11
        }
        Evac.idStart = config.idStart or 50000
        Evac.loadUnloadPerIndividual = config.loadUnloadPerIndividual or 30
        Evac.lossFlags = config.lossFlags or {'GremlinEvacRedLoss', 'GremlinEvacBlueLoss'}
        Evac.lossThresholds = config.lossThresholds or {25, 25}

        if config.maxExtractable ~= nil then
            for _side, _extractable in ipairs(config.maxExtractable) do
                if _extractable ~= nil then
                    Evac.maxExtractable[_side]['Ejected Pilot'] = _extractable['Ejected Pilot'] or 0
                    Evac.maxExtractable[_side].Infantry = _extractable.Infantry or 0
                    Evac.maxExtractable[_side].M249 = _extractable.M249 or 0
                    Evac.maxExtractable[_side].RPG = _extractable.RPG or 0
                    Evac.maxExtractable[_side].StingerIgla = _extractable.StingerIgla or 0
                    Evac.maxExtractable[_side]['2B11'] = _extractable['2B11'] or 0
                    Evac.maxExtractable[_side].JTAC = _extractable.JTAC or 0
                end
            end
        end

        Evac.spawnWeight = config.spawnWeight or 100
        Evac.spawnRates = config.spawnRates or {
            _global = {{
                units = 0, -- 0 loads all; + adds, - subtracts
                per = 0, -- 0 means only at launch; + every, - once after
                period = Gremlin.Periods.Second
            }, {
                units = 0, -- 0 loads all; + adds, - subtracts
                per = 0, -- 0 means only at launch; + every, - once after
                period = Gremlin.Periods.Second
            }}
        }

        if config.startingZones ~= nil then
            for _, _zone in pairs(config.startingZones) do
                local _mode = _zone.mode or Evac.modes.EVAC

                if Evac.modeToText[_mode] ~= nil then
                    Evac.zones[Evac.modeToText[_mode]].register(_zone.name, _zone.smoke, _zone.side)

                    if _zone.active then
                        Evac.zones[Evac.modeToText[_mode]].activate(_zone.name)
                    end
                else
                    Gremlin.log.error("Can't find " .. Gremlin.SideToText[_zone.side] .. ' zone ' .. _zone.name)
                end
            end
        end

        Evac.winFlags = config.winFlags or {'GremlinEvacRedWin', 'GremlinEvacBlueWin'}
        Evac.winThresholds = config.winThresholds or {75, 75}

        Gremlin.log.debug(Evac.Id, string.format('Configuration Loaded : %s', mist.utils.tableShowSorted({
            beaconBatteryLife = Evac.beaconBatteryLife,
            beaconSound = Evac.beaconSound,
            carryLimits = Evac.carryLimits,
            idStart = Evac.idStart,
            loadUnloadPerIndividual = Evac.loadUnloadPerIndividual,
            lossFlags = Evac.lossFlags,
            lossThresholds = Evac.lossThresholds,
            maxExtractable = Evac.maxExtractable,
            spawnWeight = Evac.spawnWeight,
            spawnRates = Evac.spawnRates,
            winFlags = Evac.winFlags,
            winThresholds = Evac.winThresholds,
        })))
    end
    -- end configuration

    trigger.action.setUserFlag(Evac.lossFlags[1], false)
    trigger.action.setUserFlag(Evac.lossFlags[2], false)
    trigger.action.setUserFlag(Evac.winFlags[1], false)
    trigger.action.setUserFlag(Evac.winFlags[2], false)

    Evac._internal.beacons.generateVHFrequencies()
    Evac._internal.beacons.generateUHFrequencies()
    Evac._internal.beacons.generateFMFrequencies()

    timer.scheduleFunction(function()
        timer.scheduleFunction(Evac._internal.doSpawns, nil, timer.getTime() + 5)
        timer.scheduleFunction(Evac._internal.beacons.killDead, nil, timer.getTime() + 5)
        timer.scheduleFunction(Evac._internal.smoke.refresh, nil, timer.getTime() + 5)
        timer.scheduleFunction(Evac._internal.menu.addToF10, nil, timer.getTime() + 5)
    end, nil, timer.getTime() + 1)

    for _name, _def in pairs(Evac._internal.handlers) do
        Evac._internal.handlers[_name].id = Gremlin.events.on(_def.event, _def.fn)

        Gremlin.log.debug(Evac.Id, string.format('Registered %s event handler', _name))
    end

    Gremlin.log.info(Evac.Id, string.format('Finished setting up %s version %s!', Evac.Id, Evac.Version))

    Evac._state.alreadyInitialized = true
end
